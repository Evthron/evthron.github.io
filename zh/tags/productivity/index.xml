<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Evthron&#39;s blog zh</title>
        <link>https://evthron.github.io/zh/tags/productivity/</link>
        <description>Recent content on Evthron&#39;s blog zh</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh</language>
        <lastBuildDate>Wed, 09 Apr 2025 15:24:56 +0800</lastBuildDate><atom:link href="https://evthron.github.io/zh/tags/productivity/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>完美主義</title>
        <link>https://evthron.github.io/zh/tweet/perfectionism/</link>
        <pubDate>Wed, 09 Apr 2025 15:24:56 +0800</pubDate>
        
        <guid>https://evthron.github.io/zh/tweet/perfectionism/</guid>
        <description>&lt;p&gt;大家總說拖延是因為完美主義，是安慰自己沒有做好的藉口。試圖把自己失敗的結果推到拖延上去。做的不好都是因為拖延，如果沒有拖延一定能做更好。&lt;/p&gt;
&lt;p&gt;我我對於這種說法一直是嗤之以鼻的，這完全不符合我的心理狀況，因為我根本就不追求什麼完美啊，事情的結果怎麼樣，我一向是無所謂的。&lt;/p&gt;
&lt;p&gt;但我突然想到，我的確是有一種完美主義的。並不是追求結果上的完美，而是準備上的完美。必須要做充足的準備。做不到完美的準備，就想要放棄。&lt;/p&gt;
&lt;p&gt;只要這樣稍微替換一下，拖延理論又適用了。&lt;/p&gt;
&lt;p&gt;在我看來，只要是自己能控制的事情，只要盡力就一定可以成功。所以追求準備上的完美和結果上的完美是一樣的。&lt;/p&gt;
&lt;p&gt;「只要盡力了就好」，這句話在我那裡反而成為了束縛。如果沒有盡力呢？就一定要陷入深深的自責嗎？&lt;/p&gt;
&lt;p&gt;換個方向，就算最後的結果是好的，只要我沒有盡力，我還是只會感覺自己是運氣好而已。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>真不想承認，認可才是我想要的動力</title>
        <link>https://evthron.github.io/zh/posts/validation-motivation/</link>
        <pubDate>Mon, 07 Apr 2025 19:36:57 +0800</pubDate>
        
        <guid>https://evthron.github.io/zh/posts/validation-motivation/</guid>
        <description>&lt;p&gt;拖延的根源並不是互聯網和遊戲。刪光遊戲、斷開網絡之後，只是從沉迷娛樂變成什麼都不做而已。&lt;/p&gt;
&lt;p&gt;我真正缺乏的是內在的動力。我想做的事情似乎都已經完成了，剩下的那些應該做的事，做不到似乎也無所謂。難道我對生活已經失去期望了嗎？&lt;/p&gt;
&lt;p&gt;回想過去，能讓我能撐過大大小小的截止日期的動力源頭，不只是外界壓力和求知欲，這些只是表象而已。真正的原因，是為了滿足我對於「上進」的自我認可，為了證明我不是個會坐以待斃的人。&lt;/p&gt;
&lt;p&gt;其實我比我自己想象中，更需要別人的認可，但我很少主動爭取。畢竟，比起冒險面對其他人的否定，先讓自己認可自己不是個更加正確的選擇嗎？&lt;/p&gt;
&lt;p&gt;這也是我寫博客的動機之一。就算沒有人讀，放在網站上的文章也是有價值的，這讓我更能認可自己。樂觀一點，説不定其他人讀了也會認同我的想法。&lt;/p&gt;
&lt;p&gt;但閉門造車的結果，就是學習偏離了方向。同樣是寫程序，我能沉迷一整天寫我自己用的腳本，卻沒有動力學習工作需要用的語言。&lt;/p&gt;
&lt;p&gt;這種自我認可本來是能給予我自信的，但到了現在要找工作的時候，面對外界真正的需求，這種自我認可突然就變得一文不值了。&lt;/p&gt;
&lt;p&gt;沒有人認可就沒有提升的動力，沒有提升的動力就沒有人認可。要逃出這個怪圈，我要盡力向身邊的人展示自己，還有按照外界的實際需要提升自己的能力，藉此認可自己。感覺依然是做不到的事，但至少我現在多看清了自己一點。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>filetags 文件管理法</title>
        <link>https://evthron.github.io/zh/toolbox/filetags/</link>
        <pubDate>Sat, 18 Jan 2025 02:14:37 +0800</pubDate>
        
        <guid>https://evthron.github.io/zh/toolbox/filetags/</guid>
        <description>&lt;p&gt;電腦上有大量的文件，為了快速找到自己需要的文件，我們會分類，把文件放到不同的文件夾裏面。分類越細，搜尋效率越高，但分類錯誤的代價也就越大：如果把文件放在了錯誤的文件夾，就可能會丟失文件；如果要修改分類結構，就需要花費大量精力重新整理文件。filetags 這套系統可以避免這個問題。&lt;/p&gt;
&lt;p&gt;在現實中，一份文件只能放在一個文件夾裏，所以要考慮分類的先後順序問題：要先按年份分類，再按作者分類，還是先按作者分類，再按年份分類？在電腦上，我們沒要必要照搬這種思路，只要能為文件同時打上作者和年份的標籤，然後按標籤搜尋就可以了。&lt;/p&gt;
&lt;p&gt;filetags 會在文件名上打標籤。文件名無論在哪裏都是通用的，不會受到工具的限制，自然也不用害怕丟失重要的標籤數據。格式是把主要文件名和標籤詞之間用「 &amp;ndash; 」分開。例如 document.txt 是 john 寫的書評，就可以把文件名改成 document &amp;ndash; john books review.txt。&lt;/p&gt;
&lt;p&gt;這種方法最適合用在散亂的文件上，例如相片和筆記。按照這種方法，檔案結構會變得非常簡單扁平：照片可以先按照時間分類，然後不加組織地放在裏面。&lt;/p&gt;
&lt;p&gt;可惜，沒有文件系統會支持這種特別的格式，要搜尋文件的話需要用作者自己寫的 Python 腳本工具，或是自己寫 Regular Expression。&lt;/p&gt;
&lt;p&gt;原作者的介紹：&lt;a class=&#34;link&#34; href=&#34;https://karl-voit.at/managing-digital-photographs/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;karl-voit.at/managing-digital-photographs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;filetags python script：&lt;a class=&#34;link&#34; href=&#34;https://github.com/novoid/filetags&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github.com/novoid/filetags&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>完美學習法</title>
        <link>https://evthron.github.io/zh/posts/ultimate-learning-method/</link>
        <pubDate>Sat, 18 Jan 2025 02:02:08 +0800</pubDate>
        
        <guid>https://evthron.github.io/zh/posts/ultimate-learning-method/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://supermemo.guru/wiki/Incremental_reading&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;增量閲讀（supermemo.guru）&lt;/a&gt;能讓我用最好的效率學會一切事物。但是有了記下一切的能力之後，要花時間記什麼就成了問題。&lt;/p&gt;
&lt;p&gt;增量閱讀的目標是維持長久的記憶，並在不斷重複閱讀的過程中分辨重點和無用的細節。不只是在幾個星期之內把材料記住，而是要在以年為單位的時間裏不斷地回顧。&lt;/p&gt;
&lt;p&gt;自己有興趣記下來的，往往是不管用的東西，外界不感興趣的東西。要是沒有根據外界的要求，記憶外界需要的學習材料，無論學什麼都只會被當成自娛自樂而已。&lt;/p&gt;
&lt;p&gt;即使可以使用增量閲讀應付考試，但強迫自己記憶不感興趣的細節，本來就違背了增量閲讀的初衷。考試結束的一瞬間，所有的知識都似乎變得無用，增量學習系統裏面存放的文章摘錄和問題卡，突然變成要慢慢清理的負債了，因為會妨礙加入新的內容。&lt;/p&gt;
&lt;p&gt;方法終究只是錦上添花。就算學習方法差了一點，人只要受到正確的鼓勵和引導，也會學得很好，沒有必要追求什麼完美學習法。&lt;/p&gt;
&lt;p&gt;想要得到正確的鼓勵和引導，可能比追求完美的學習法還要困難。知識是免費的，而人是無價的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這對於 AI 也是適用的。AI 唯一不能解答的就是我應該學什麼。不過，這個世界上有人能告訴我學什麼對未來最有用嗎？&lt;/p&gt;
</description>
        </item>
        <item>
        <title>定製 Taskwarrior</title>
        <link>https://evthron.github.io/zh/toolbox/taskwarrior-hooks/</link>
        <pubDate>Mon, 25 Nov 2024 01:51:20 +0800</pubDate>
        
        <guid>https://evthron.github.io/zh/toolbox/taskwarrior-hooks/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://taskwarrior.org&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Taskwarrior&lt;/a&gt; 是一個簡單不花俏，功能豐富的待辦清單軟件。我自己改裝了一下。&lt;/p&gt;
&lt;p&gt;第一是實現了性價比排序功能。這是模仿 Supermemo 裏的 &lt;a class=&#34;link&#34; href=&#34;https://supermemo.guru/wiki/Tasklist&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tasklist&lt;/a&gt; 功能，可以每個任務估算時間和價值，然後按照價值除以時間，也就是性價比排序。&lt;/p&gt;
&lt;p&gt;首先在 taskrc 裏設定 UDA (User Defined Attributes，用户定義的屬性）分別是 Time， Value，和 Worth（= Value / Time）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 不知道為什麼，要是把 Time 和 Value 和定義為 numeric type 的話，顯示就會延伸到小數後很多位。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;uda.time.type&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;string
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;uda.time.label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Time
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;uda.value.type&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;string
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;uda.value.label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;uda.worth.type&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;numeric
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;uda.worth.label&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Worth
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然後修改 report.list 的欄位，加入 Time, Value，和 Worth&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;default.command&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;list &lt;span style=&#34;color:#75715e&#34;&gt;# 輸入 task 的時候自動執行 task list，而不是 task next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;report.list.columns&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;id,start.age,entry.age,depends.indicator,priority,project,tags,recur.indicator,scheduled.countdown,due,until.remaining,description.count,time,value,worth
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;report.list.labels&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;ID,Active,Age,D,P,Project,Tags,R,Sch,Due,Until,Description,Time,Value,Worth
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最後是根據 worth，也就是性價比排序&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;report.list.sort&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;worth-,start-,due+,project+
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt; task add 買牛奶 time:60 value:30
# 買牛奶要花 60 分鐘
# 我覺得買牛奶對我來説值 30 元

# 顯示效果
ID | Active | Age | Description | Time | Value | Worth  |
19 |        | 1s  | 買牛奶      |  60  |  30   | 0.500  |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要讓 taskwarrior 自動計算性價比，就需要用到 hooks，也就是自動和 taskwarrior 一起運行的程序。寫兩個 Shell Script，分別是 on-add.01.prioirty 和 on-modify.01.priority，一個在增加任務的時候執行，另一個在修改任務的時候執行。兩個 Shell Script 的內容是一樣的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/usr/bin/env bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;TASK&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;&amp;lt;/dev/stdin&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$TASK&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; | python &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/.config/task/hooks/priority.py&amp;#34;&lt;/span&gt; $@ 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次增加或者修改任務，任務就會以 JSON 的形式交給 priority.py 處理，計算任務的性價比。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; sys
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; json
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loads(sys&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;stdin&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readline())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decoder&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;JSONDecodeError:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# worth calculation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;time&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; task&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;keys() &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; task&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;keys():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    task[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;worth&amp;#39;&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{:.3f}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(int(float(task[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;value&amp;#39;&lt;/span&gt;])) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; int(float(task[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;time&amp;#39;&lt;/span&gt;]))))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dumps(task))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第二是我用了 &lt;a class=&#34;link&#34; href=&#34;https://github.com/oskapt/task2hab&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;task2hab (github)&lt;/a&gt; 這個插件，可以自動把 taskwarrior 的任務同步到 habitica 上。另外我還模仿了另一個插件 &lt;a class=&#34;link&#34; href=&#34;https://github.com/robwhitaker/taskwarrior-habitica-bridge&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;taskwarrior-habitica-bridge (github)&lt;/a&gt;，修改了一點代碼，讓完成任務的時候可以在終端裏顯示賺到的經驗和金幣。因為這個不是我寫的，我就不展開説了。&lt;/p&gt;
&lt;p&gt;第三，我還做了個能顯示每日金句的功能，這個功能很簡單，只是調用別人的 API 而已。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>時間管理工具</title>
        <link>https://evthron.github.io/zh/tweet/productivity-tools/</link>
        <pubDate>Tue, 19 Mar 2024 20:20:35 +0800</pubDate>
        
        <guid>https://evthron.github.io/zh/tweet/productivity-tools/</guid>
        <description>&lt;p&gt;不工作跑去研究工具是沒有好下場的。不過 Super Productivity 和 ActivityWatch 用起來都不錯。要怎樣運用徹底監控電腦使用時間得到的數據，才能把生活變成數值管理遊戲？不過總之先記錄，其他問題以後再想。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我想破頭之後總算明白了，我手上的時間管理工具在功課上派不上用場。&lt;/p&gt;
&lt;p&gt;待辦清單適合處理繁瑣的工作，但我通常只有四五份功課，根本不需要特意記下來，每一份又要花幾天才能做完，一定要先拆成一個個簡單的步驟，才能放進待辦清單，但沒做過，又怎麼知道任務能不能拆開？空泛地亂拆又沒有用。&lt;/p&gt;
&lt;p&gt;這樣一來，似乎根本不需要用什麼時間管理工具，埋頭苦幹一天做完就行了。但「埋頭苦幹一天」太嚇人了，結果只會拖着，永遠不會開始。而且，一天做完的作業質量肯定不好。和寫文章一樣，要每過幾天重新看一次，不斷修改才可以。&lt;/p&gt;
&lt;p&gt;靠軟件幫忙安排工作，一邊做一邊分拆任務，把拆開的任務分成很多天處理，每次只做一小部分，減輕內心的恐懼，是最好的做法。但是軟件的排程不會理會截止日期，沒法保證一定能在規定的時間內完成。&lt;/p&gt;
&lt;p&gt;説到底，截止日期這個概念本來就是想當然的產物。如果能明確地預測工作時間的話，就直接用那個時間好了。但工作時間當然是無法預測的，只能設一個過分充裕的期限，讓人變得拖拖拉拉。&lt;/p&gt;
&lt;p&gt;我理想的時間管理工具該有的要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任務隊列，按照緩急輕重和完成的收穫自動安排每日的任務，出現什麼就做什麼，沒得選。&lt;/li&gt;
&lt;li&gt;每項任務都是一個文本檔案，因為無論什麼任務都需要寫工作筆記。&lt;/li&gt;
&lt;li&gt;遇見複雜的任務可以拆開，形成樹狀分支&lt;/li&gt;
&lt;li&gt;任務清單，能觀察自己每個項目的進度，彌補任務隊列把任務拆得亂七八糟，見樹不見林的不足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了會很好：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能自動打開任務需要的檔案，減少切換的麻煩&lt;/li&gt;
&lt;li&gt;遊戲化，在完成任務的時候會「叮」的一下加分。&lt;/li&gt;
&lt;li&gt;能製作記憶卡，混入任務隊列&lt;/li&gt;
&lt;li&gt;時間追蹤，提醒自己不要在同一個任務上花太多時間。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;雖然把一大堆工具合併起來用就能滿足上面的所有要求，但如果還是要奢望有一個萬能的合體機器人的話，就只會走上 emacs 的不歸路。怎麼辦，好像很吸引人……&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;又不小心研究了一會 emacs，因為 orgdown 的語法好像比 markdown 好。練習快捷鍵除了輸入的時候比較爽快沒有什麼意義。我很滿意 vim。過早的優化是萬惡之源。有些人連盲打都不會呢，照樣能寫出好的程序。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;記錄浪費了的時間的最大好處不是獲得數據，而是用記錄的動作作為行動的開關，有意識地「浪費」時間。逃避結束的時候同時結束記錄，作為切換狀態的訊號。計時是讓無意義的按按鈕儀式變得有意義的把戲，順帶能了解自己的習慣，知道自己真正需要多少逃避的時間。&lt;/p&gt;
&lt;p&gt;逃避行為：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;思考抽象宏大的問題&lt;/li&gt;
&lt;li&gt;學習不迫切的知識&lt;/li&gt;
&lt;li&gt;觀看流行的新聞和娛樂影片&lt;/li&gt;
&lt;li&gt;搜尋新的音樂&lt;/li&gt;
&lt;li&gt;發呆、踱步&lt;/li&gt;
&lt;li&gt;無目的地聊天和抱怨&lt;/li&gt;
&lt;li&gt;寫反省的文章&lt;/li&gt;
&lt;li&gt;研究新項目&lt;/li&gt;
&lt;li&gt;重温喜歡的故事&lt;/li&gt;
&lt;li&gt;沉溺幻想&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;被動地用軟件記錄，或者記錄不會重複的事件都是沒有意義的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;比想象中困難，確認自己的行動狀態不是這麼簡單的，不知不覺間就會切換到別的狀態。&lt;/p&gt;
&lt;p&gt;要搞清楚自己的娛樂有多少是需求，多少是逃避，多少是無意識的習慣。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;讓人保持理智的技巧往往需要理智才能實行，這個也不例外。就算只按個按鈕也好。連按鈕都按不下去，無法承認自己的行動的時候，就應該休息了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>重設鍵盤佈局</title>
        <link>https://evthron.github.io/zh/toolbox/remap-keyboard/</link>
        <pubDate>Thu, 21 Dec 2023 22:44:00 +0800</pubDate>
        
        <guid>https://evthron.github.io/zh/toolbox/remap-keyboard/</guid>
        <description>&lt;p&gt;現在的鍵盤佈局完全沒有考慮過人體工學：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;沒好好利用有力的拇指，反而浪費兩隻手指按一個空格鍵。難得兩個 Alt 鍵很容易用拇指按到，卻不常用。&lt;/li&gt;
&lt;li&gt;常用的 Enter 和 Backspace 要用小指去按，還離得很遠。&lt;/li&gt;
&lt;li&gt;沒用的 CapsLock 放在了小指能輕鬆按到的位置。如果你習慣用 CapsLock 打大寫字母的話，我建議你改用 Sticky Keys。&lt;/li&gt;
&lt;li&gt;還有一個少數人才能遇到的問題：文字編輯器 Vim 很常用到 Esc 鍵，但這個鍵居然在鍵盤的左上角。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至少要改成這樣才算理想的鍵位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Capslock -&amp;gt; Backspace&lt;/li&gt;
&lt;li&gt;Left Alt -&amp;gt; Esc&lt;/li&gt;
&lt;li&gt;Right Alt -&amp;gt; Enter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鍵盤上還有不少多餘的鍵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面一排 F1 到 F12 沒什麼用。有用的預設功能只有 F2 （重新命名）和 F3（搜尋）；勉強稱得上有用的有 F4 (Alt+F4 強制關閉窗口)、F11（放大窗口到全屏幕）；只有網頁開發人員有用的有 F12（打開網頁源代碼）。這些功能真的值得專門佔一個寶貴的鍵嗎？&lt;/li&gt;
&lt;li&gt;Insert、Pause、ScrollLock，NumLock，這些鍵已經沒有意義了。Home、End、PgUp、PgDn 也不算常用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一方面，快捷鍵的設計也是在折磨手指。軟件的快捷鍵一大堆，常用的就那麼幾個，還可能是 Ctrl + Shift + Alt + P 之類的奇怪組合。用鍵盤上多餘的鍵取代組合鍵就再適合不過了。我們應該好好感謝這些殘留下來的歷史按鍵，多一個鍵，就能多設定一個功能。&lt;/p&gt;
&lt;p&gt;AutoHotKey 是 Windows 的改鍵工具。很簡單就能實現這些要求。我把鍵盤設定成這樣：&lt;/p&gt;
&lt;h2 id=&#34;打字&#34;&gt;打字&lt;/h2&gt;
&lt;p&gt;打字舒服是最重要的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Capslock -&amp;gt; Backspace&lt;/li&gt;
&lt;li&gt;Left Alt -&amp;gt; Esc&lt;/li&gt;
&lt;li&gt;Right Alt -&amp;gt; Enter
這麼一來就沒有 Alt 可以用了，可以把 Alt 搬到 Compose 、Right Ctrl、Backspace、或者某個 Fn 鍵上，偶爾會用得上。&lt;/li&gt;
&lt;li&gt;Enter -&amp;gt; Win + Space（切換中英文輸入法）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;瀏覽器操作&#34;&gt;瀏覽器操作&lt;/h2&gt;
&lt;p&gt;真不知道這些快捷鍵是誰設計的。説起來也可以安裝插件，用 Vim 鍵位操作頁面，但我覺得還是方向鍵比較方便。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;F6 -&amp;gt; Shift + Ctrl + T （打開上一個關閉的分頁）&lt;/li&gt;
&lt;li&gt;Delete -&amp;gt; Ctrl + W （關閉分頁）&lt;/li&gt;
&lt;li&gt;PgUp -&amp;gt; Ctrl + Shift + Tab （往前一個分頁）&lt;/li&gt;
&lt;li&gt;PgDn -&amp;gt; Ctrl + Tab (往後一個分頁)&lt;/li&gt;
&lt;li&gt;Insert -&amp;gt; Ctrl + T （新增分頁）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;啓動軟件&#34;&gt;啓動軟件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;F1: 番茄鐘&lt;/li&gt;
&lt;li&gt;F4: 字典（Saladict）&lt;/li&gt;
&lt;li&gt;F7: 命令窗口（Terminal）&lt;/li&gt;
&lt;li&gt;F8: 筆記軟件（Vim）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我的鼠標上有兩個額外的鍵用作複製和貼上。如果鼠標上沒有額外按鍵的話，我還會把它們放在兩個 Fn 鍵上。&lt;/p&gt;
&lt;p&gt;AutoHotKey 有一些缺點，你用着用着就知道了。ahk 腳本的格式不太容易學；登入界面和資源管理器是用不了快捷鍵的，因為這些都需要需要系統管理員權限。不過功能很豐富，可以滿足一切自動操作的需求。&lt;/p&gt;
&lt;h2 id=&#34;keyd&#34;&gt;Keyd&lt;/h2&gt;
&lt;p&gt;不知道算 Linux 上沒有 Autohotkey 算不算可惜。不過我也不需要那麼多亂七八糟的功能，只要能改鍵就好。keyd 是 Linux 上的一個簡單易用的替代品。缺點是沒有辦法按每個程序設置快捷鍵，只能設置全局快捷鍵。而且輸出受到鍵盤佈局影響，我同時使用 qwerty 的中文輸入和 dvorak，有時候就會出錯。&lt;/p&gt;
&lt;p&gt;「在偏門的佈局上打得飛快，反而在普通的鍵盤上就打不出字來，不是本末倒置嗎？」不用擔心，我已經掌握了在兩種鍵盤佈局之間切換的能力，並深深體會到了兼容的意義。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
