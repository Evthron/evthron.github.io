[{"content":"真的有人能把剛切好的西瓜放着不動嗎？ ","date":"2025-01-03T12:52:15+08:00","image":"https://evthron.github.io/zh/gallery/watermelon/watermelon_hu11916272169102576235.jpg","permalink":"https://evthron.github.io/zh/gallery/watermelon/","title":"瓜皮"},{"content":" ","date":"2025-01-03T12:49:52+08:00","image":"https://evthron.github.io/zh/gallery/minibus/minibus_hu17334317661795685558.jpg","permalink":"https://evthron.github.io/zh/gallery/minibus/","title":"小巴"},{"content":" ","date":"2025-01-03T12:35:45+08:00","image":"https://evthron.github.io/zh/gallery/beach/beach_hu10679375173992973574.jpg","permalink":"https://evthron.github.io/zh/gallery/beach/","title":"海灘"},{"content":" 原版 反色相 反亮度 反飽和度 反色相 + 反亮度 反色相 + 反飽和度 ","date":"2025-01-03T12:17:12+08:00","image":"https://evthron.github.io/zh/gallery/colour-practice/colour-practice_hu14286914602695835229.png","permalink":"https://evthron.github.io/zh/gallery/colour-practice/","title":"顏色練習"},{"content":"雖然這個比較寫實，但不知道為什麼還是原來用滑鼠畫的圖標好看。 ","date":"2025-01-03T12:10:59+08:00","image":"https://evthron.github.io/zh/gallery/labcoat/labcoat_hu14068743690435711825.png","permalink":"https://evthron.github.io/zh/gallery/labcoat/","title":"實驗袍"},{"content":" ","date":"2025-01-03T12:01:28+08:00","image":"https://evthron.github.io/zh/gallery/christmas-house/christmas-house_hu6795415540570487758.png","permalink":"https://evthron.github.io/zh/gallery/christmas-house/","title":"聖誕屋"},{"content":" ","date":"2025-01-03T11:41:48+08:00","image":"https://evthron.github.io/zh/gallery/body-skeleton/body-skeleton_hu8695584027130602566.png","permalink":"https://evthron.github.io/zh/gallery/body-skeleton/","title":"人體動態"},{"content":"beautiful soup 只是用來 parse 收回來的 respones\ndef parse_reddit_page(url): headers = { \u0026#34;User-Agent\u0026#34;: ( \u0026#34;Mozilla/5.0 (X11; Linux ex86_64; rv:105.0) \u0026#34; \u0026#34;Gecko/20100101 \u0026#34; \u0026#34;Firefox/105.0\u0026#34; ) } response = requests.get(url, headers=headers) # raise error code if problem occurs response.raise_for_status() soup = BeautifulSoup(response.text, \u0026#34;html.parser\u0026#34;) note_body = [] # parse post entry = soup.find(\u0026#34;div\u0026#34;, class_=\u0026#34;entry\u0026#34;) author = entry.find(\u0026#34;a\u0026#34;, class_=\u0026#34;author\u0026#34;) title = entry.find(\u0026#34;a\u0026#34;, class_=\u0026#34;title\u0026#34;) note_title = f\u0026#34;{author.text}: {title.text}\u0026#34; body = entry.find(\u0026#34;div\u0026#34;, class_=\u0026#34;md\u0026#34;) note_body.append(md(str(body))) # parse comments note_body.append(\u0026#34;## Comments\\n\\n\u0026#34;) comment_area = soup.find(\u0026#34;div\u0026#34;, class_=\u0026#34;commentarea\u0026#34;) comments = comment_area.find_all(\u0026#34;div\u0026#34;, class_=\u0026#34;entry\u0026#34;) for comment in comments: comment_author = comment.find(\u0026#34;a\u0026#34;, class_=\u0026#34;author\u0026#34;) if comment_author is None: # This is the \u0026#34;continue thread\u0026#34; element continue comment_body = comment.find(\u0026#34;div\u0026#34;, class_=\u0026#34;md\u0026#34;) note_body.append(f\u0026#34;**{comment_author.text}**: {md(str(comment_body))}\u0026#34;) return note_title, \u0026#34;\u0026#34;.join(note_body) ","date":"2025-01-03T04:49:30+08:00","permalink":"https://evthron.github.io/zh/code/reddit-clipper/","title":"reddit-clipper"},{"content":"我的待辦清單，想到什麼就加進去。\nAge Description ----- -------------------------------------------------------------------------- 2w make resume 8w watch job brief 6d draw new blog background from postcard 6d redraw ai-generated-image 6d write about privacy anonymity 12w write language compare code article 10w add a link page to my blog 6d code task warrior hook for motivational quote 6d buy a domain 5d write categorization and filetags 5d write math reinvention and my story of factorization 4w writing university problem of common space and study group, what should friends do together 3mo ask for emacs and org-mode 10w set up local habitica server 2w make foreign function using anki-connect 8d add tag search feature to blog 6d write how a make the painter progress bar 8d code tic-tac-toe on blog 6d write fake creation and real idea 12w incremental video in obsidian 6d code step count chart 10w write about why obsidian plugin not attractive enough 5w code a youtube download credit system 2w code recreate pluckeye 2w code recreate habitica search token 4w code track social life, random pick 12d change input method word order cheng du 7d write reason to draw 4d write my first programming languag 4d write meaning of sending presents 4d write failed cooking plan 4d write hate change clothes outside 4d write meaning of my own website 4d write I hate dreams 4d code copy post to multiple language when more than one language tag 4d code copy notion library layout 3d write why I dont like travel 3d write about how story pattern works 3d write localhost blog bug 3d write complete mountain story 2d write introduction to toki pona 2d write update docker nftables 2d watch krita tutorial 2d write passion to music 2d write update post overnight, tired of it 1d write tweet terminal to gui gap 1d anki api to auto output vocab list with tags 18h write ultimate learning method 18h sample out of tune piano 18h code show knowledge exchange on blog 18h write translate say-goodbye-to-internet 18h change site font 17h write home is prison, prison is home 17h write accustom to loneliness is very bad 17h read source code of clocktower 17h write update blog home page 17h add books to right-sider 55s write regex notes 2s code taskwarrior layout on blog ","date":"2024-12-31T08:01:55+08:00","permalink":"https://evthron.github.io/zh/sandbox/taskwarrior/","title":"taskwarrior"},{"content":"What is:\nunset // Go back to last inherited value. flex-grow, flex-shrink // Decide which and how the element takes up remaining spaces; flex-warp; // opposite to overflow:scroll, make newline if too many flex element align-items: flex-start; //Align the element on the direction perpendicular to the flex direction. For row, stick to the top of the box. display: inline-flex; // Set the outer display model of the box to be flex as well display: inline-block; // Block vs inline vs inline-block. inline-block is a bit like flex blox? overflow-y: scroll; // Create scroll bar when element overflows ","date":"2024-12-30T23:55:28+08:00","permalink":"https://evthron.github.io/zh/sandbox/css/","title":"CSS note"},{"content":"請教其他人是很困難的事。自己在時間充足的時候沒有尋求協助，貪圖眼前的安逸，把問題放着不管，直到無可奈何的時候才醒覺自己沒有辦法解決問題，拉下臉找人幫忙。比起面對這種羞愧的感覺，還不如自暴自棄。\n深入思考一下，為什麼尋求幫助是這麼困難的事呢？是缺乏信任嗎？既然沒有網絡搜尋解決不了的問題，普通的發問又有什麼意義呢？比起承認自己的無知，直接在網上找答案不是更輕鬆嗎？仰賴互聯網解決問題，就喪失了在解決小問題的時候培養信任的機會。不過我也不知道在不能上網的時候，人們是怎麼交流的。説不定還是一樣。\n在自己準備充足的時候請求幫助沒什麼大不了，只是提出對方有能力處理的請求，得到預想之中的答案而已。這些請求並不是內心真正的擔憂，即使被拒絕了也無關緊要。既然請求的時候沒有相信對方，就算對方真心地提供了協助，也沒辦法培養信任。\n是我不夠害怕嗎？真的遇到感覺自己就要死的危機的時候，我本能地會抓住一切能用的幫助，連想都不用想一下。社會的危機太抽象了，沒法激起人的本能反應嗎？\n是我根本不相信別人的幫助對自己會有用嗎？畢竟所謂的合作往往是一個人獨自解決問題之後分享解決方案，真正一起合作解決問題的經歷實在很罕見，我也只有在解決數學題目的時候經歷過一次而已。\n但是反過來，如果有人找我幫忙的話，我總能馬上行動起來。有時可能會覺得驚喜，有時可能會覺得有點厭煩，但能讓我動起來總是好事。\n","date":"2024-12-28T05:02:27+08:00","permalink":"https://evthron.github.io/zh/tweet/hard-to-ask-for-help/","title":"求助很困難"},{"content":"我把文章發佈到網站的流程其實還挺複雜的，在這裏説明一下。\n我用 hugo（網站鏈接） 這個網站生成器建立網站，只要把文字和圖片擺放成 hugo 指定的結構，就可以把它們轉換成網站的代碼，然後把整份代碼上傳到網上去。\nhugo 用 content 文件夾存放全部文章內容。可以設置文章分區，每個文章分區都是個文件夾。文章本身也是個文件夾，同一篇文章的多個語言版本都會放在裏面。\nblog content gallery posts cardinal-ordinal index.en.md index.zh.md 但我不會直接在這文件夾裏增加文章，而是先在 Joplin 寫好，再用代碼把文章自動複製到適合的位置。\nJoplin 的筆記本結構和上面一樣。每篇文章都是一個筆記本，放在分區筆記本裏，文章筆記本裏放不同語言的文章。\nposts cardinal-ordinal 量數和序數 Cardinals and ordinals 為了區分沒寫完的文章和要發佈的文章，我會用 Joplin 的標籤功能，在準備好發佈的文章上加一個語言標籤。\n然後我會用 python 導出文章到 content 文件夾，再用 shell script 生成網站代碼然後上傳。\n以上就是大致的流程，接下來要説一些代碼了。到底要怎麼把文章按照需要的結構，從 Joplin 導出到 content 文件夾裏面呢？joppy (github) 把 Joplin 的 API 用 Python 包裝了一遍，這樣我就能用 python 存取 Joplin 的筆記了。\n除了要上傳的文章以外，我的 Joplin 裏面還放了幾百篇不相關的筆記，如果要逐篇筆記檢查它屬於哪本筆記本的話會很耗時間。我只想檢查需要的筆記本，但是這個 API ，或者説 Joplin 存放文件的結構，有個麻煩的地方。所有的筆記本雖然表面上有層級關係，實際上是平級的。我不能像一般的樹狀結構一樣從最頂層往下搜尋筆記本，而是只能從底層，也就是所有筆記本開始往上篩選，才能知道這個筆記本的上一級到底是哪一個筆記本。舉個例子，我要查看 cardinal-ordinal 筆記本才能知道它的上一級是 posts 筆記本，而不能直接查看 posts 筆記本裏面有什麼筆記本。這種結構好像是叫作 Parent list，每個端點會指向它的 Parent。\n這樣就知道怎樣篩選筆記本了，剩下的就只是麻煩的搬運工作，代碼如下：\nimport os from joppy.client_api import ClientApi as Api # 調用 joppy 的 API api = Api(token=\u0026#34;YOUR_API_TOKEN\u0026#34;) def output_posts_in_certain_notebook_id(all_notebooks, notebook_id): category = api.get_notebook(notebook_id).title for notebook_data in all_notebooks: # 只有當筆記本（文章）放在需要的筆記本（分區）裏面才繼續 if notebook_data.parent_id != None and notebook_data.parent_id == notebook_id: # 獲取筆記本裏面的所有筆記（不同的語言版本） post_list = api.get_notes(notebook_data.id, fields=\u0026#39;created_time,updated_time,body,order,title,id\u0026#39;) folder_name = notebook_data.title print(notebook_data.title) zh_posts = [] en_posts = [] tok_posts = [] for post_language_version in post_list.items: title = post_language_version.title \u0026#39;\u0026#39;\u0026#39; 如果文章沒有標籤，就跳過 \u0026#39;\u0026#39;\u0026#39; tag_list = get_tag_list(post_language_version.id) if not tag_list: continue # 把文章按語言版本分類 if \u0026#39;zh\u0026#39; in tag_list: language_code = \u0026#39;zh\u0026#39; zh_posts.append(post_language_version) elif \u0026#39;en\u0026#39; in tag_list: language_code = \u0026#39;en\u0026#39; en_posts.append(post_language_version) elif \u0026#39;tok\u0026#39; in tag_list: language_code = \u0026#39;tok\u0026#39; tok_posts.append(post_language_version) else: continue combine_and_output_posts_in_same_language(category, folder_name, \u0026#39;zh\u0026#39;, zh_posts) combine_and_output_posts_in_same_language(category, folder_name, \u0026#39;en\u0026#39;, en_posts) combine_and_output_posts_in_same_language(category, folder_name, \u0026#39;tok\u0026#39;, tok_posts) def combine_and_output_posts_in_same_language(category, folder_name, language_code, posts): if posts: \u0026#39;\u0026#39;\u0026#39; 這是個把拆成幾段的筆記合併到一起的功能。我是想着用來把一段段的小説合併起來，不過還沒有什麼實際作用 \u0026#39;\u0026#39;\u0026#39; posts.sort(key=lambda x: x.order, reverse=True) title = posts[0].title tag_list = get_tag_list(posts[0].id) tag_list.remove(language_code) body = \u0026#39;\u0026#39; created_time = None updated_time = None for post in posts: if (created_time is None) or (post.created_time \u0026lt; created_time): created_time = post.created_time if (updated_time is None) or (post.updated_time \u0026gt; updated_time): updated_time = post.updated_time body += post.body + \u0026#39;\\n\\n\u0026#39; \u0026#39;\u0026#39;\u0026#39; 提取筆記的資料，然後扔到 generate_front_matter() 裏面，自動生成 hugo 需要的 markdown front matter，也就是文章的屬性資料。 \u0026#39;\u0026#39;\u0026#39; date = created_time.isoformat()[:19] + \u0026#39;+08:00\u0026#39; lastmod = updated_time.isoformat()[:19] + \u0026#39;+08:00\u0026#39; home_dir = os.environ[\u0026#39;HOME\u0026#39;] \u0026#39;\u0026#39;\u0026#39; 如果文件夾裏放了圖片，自動在 front matter 裏加入資料，作為文章的標題圖片。 \u0026#39;\u0026#39;\u0026#39; feature_png_directory = home_dir + \u0026#39;/Blog/blog/evthronblog/content/\u0026#39; + category + \u0026#39;/\u0026#39; + folder_name + \u0026#39;/\u0026#39; + folder_name + \u0026#39;.\u0026#39; + \u0026#39;png\u0026#39; feature_jpg_directory = home_dir + \u0026#39;/Blog/blog/evthronblog/content/\u0026#39; + category + \u0026#39;/\u0026#39; + folder_name + \u0026#39;/\u0026#39; + folder_name + \u0026#39;.\u0026#39; + \u0026#39;jpg\u0026#39; if os.path.exists(feature_png_directory): image = folder_name + \u0026#39;.png\u0026#39; front_matter = generate_front_matter(title, date, lastmod=lastmod, tags=repr(tag_list), categories=category, image=image) elif os.path.exists(feature_jpg_directory): image = folder_name + \u0026#39;.jpg\u0026#39; front_matter = generate_front_matter(title, date, lastmod=lastmod, tags=repr(tag_list), categories=category, image=image) else: front_matter = generate_front_matter(title, date, lastmod=lastmod, tags=repr(tag_list), categories=category) \u0026#39;\u0026#39;\u0026#39; 把生成的 Markdown 文章複製到指定的文件夾裏面 \u0026#39;\u0026#39;\u0026#39; folder_directory = home_dir + \u0026#39;/Blog/blog/evthronblog/content/\u0026#39; + category + \u0026#39;/\u0026#39; + folder_name if not os.path.exists(folder_directory): os.makedirs(folder_directory) path = folder_directory + \u0026#39;/index.\u0026#39; + language_code + \u0026#39;.md\u0026#39; with open(path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as fout: fout.write(front_matter + \u0026#39;\\n\u0026#39; + body) print(\u0026#34;done in\u0026#34;, language_code) else: print(\u0026#34;no post in\u0026#34;, language_code) def generate_front_matter(title, date, description = \u0026#39;\u0026#39;, lastmod = \u0026#39;\u0026#39;, image = \u0026#39;\u0026#39;, categories = \u0026#39;\u0026#39;, tags = \u0026#39;\u0026#39;, slug = \u0026#39;\u0026#39;, layout = \u0026#39;\u0026#39;) -\u0026gt; str: if lastmod == \u0026#39;\u0026#39;: lastmod = strftime(\u0026#34;%Y-%m-%dT%H:%M:%S+08:00\u0026#34;, localtime()) front_matter = \u0026#39;---\\n\u0026#39; front_matter += \u0026#39;title: \u0026#34;\u0026#39; + title + \u0026#39;\u0026#34;\\n\u0026#39; front_matter += \u0026#39;description: \u0026#39; + description + \u0026#39;\\n\u0026#39; front_matter += \u0026#39;date: \u0026#39; + date + \u0026#39;\\n\u0026#39; front_matter += \u0026#39;lastmod: \u0026#39; + lastmod + \u0026#39;\\n\u0026#39; front_matter += \u0026#39;image: \u0026#39; + image + \u0026#39;\\n\u0026#39; front_matter += \u0026#39;categories: \u0026#39; + categories + \u0026#39;\\n\u0026#39; front_matter += \u0026#39;tags: \u0026#39; + tags + \u0026#39;\\n\u0026#39; front_matter += \u0026#39;math: \\nlicense: \\nhidden: false\\ncomments: true\\n\u0026#39; if slug: front_matter += \u0026#39;slug: \u0026#34;\u0026#39; + slug + \u0026#39;\u0026#34;\\n\u0026#39; if layout: front_matter += \u0026#39;layout: \u0026#34;\u0026#39; + layout + \u0026#39;\u0026#34;\\n\u0026#39; front_matter += \u0026#39;---\\n\u0026#39; return front_matter def get_tag_list(note_id): info = api.get_tags(note_id).items tag_list = [] if info: for tagdata in info: tag = tagdata.title tag_list.append(tag) return tag_list def main(): all_notebooks = api.get_all_notebooks() # 為需要的筆記本生成檔案 post_notebook_id = \u0026#39;PUT_NOTEBOOK_ID_HERE\u0026#39; output_posts_in_certain_notebook_id(all_notebooks, post_notebook_id) gallery_notebook_id = \u0026#39;PUT_NOTEBOOK_ID_HERE\u0026#39; output_posts_in_certain_notebook_id(all_notebooks, gallery_notebook_id) if __name__ == \u0026#39;__main__\u0026#39;: main() 如果我完全不用 Joplin 的話，流程應該可以變得更簡單一些，但我做得這麼辛苦，不是很想改。\n","date":"2024-12-27T06:01:25+08:00","permalink":"https://evthron.github.io/zh/toolbox/upload-workflow/","title":"文章發佈流程"},{"content":"「保持聯絡」絕不是客套話，友誼是從見面的第一天起就開始玩的乒乓球，你來我往，不能停下來。但我空有這種觀念，還是當不成一個好朋友，因為只要離開了自己的視線，我就幾乎不會去關心別人過得怎麼樣。大部分人關心的事，我不是覺得害怕，就是覺得沒意義。\n志同道合 每個人都關心考試成績和將來的出路，但我總是避免思考這些問題。我學習只是順着自己淺薄的好奇心，沒有興趣鑽研複雜的題目；複習也只是害怕考試不及格，對分數沒有什麼追求。我害怕討論考試，和工作有關的事更是我的死穴，每次有人和我聊到這些話題，我就會小心翼翼地架起防禦，生怕別人發現我只是個不知道自己想要什麼的人。\n我的眼界很狹窄，想做到的事也沒有社會上的價值，非常微不足道。我想，自己的志向不是自己想出來的也可以。無論是打擊也好，鼓勵也好，如果有朋友的啓發，我應該能找到更像樣一點的目標才對。\n意氣相投 如果只是想找人玩的話應該不難，但我已經對娛樂活動不感興趣了。我還花了很多心力排除這些干擾，故事、遊戲和音樂在我看來都是讓人分心的娛樂，是逃避現實的方法。就算我能靠着以前的經驗，興高采烈地分享自己對某部作品的感想，內心還是覺得不自在。\n這種想法讓我少了一個聯絡朋友的絕佳藉口。而且，一般人就算活在這些娛樂裏面，也不是一樣過得很好嗎？他們會説，一天到晚看短片、玩手遊又怎麼樣？只要在應該做事的時候把事情做好不就可以了嗎？工作的動力不就是賺更多錢，享受更豐富的娛樂嗎？我也不能昂首挺胸地叫其他人和我一樣試着擺脱娛樂，因為我就算這樣做了，也沒做出什麼成果。\n其實參加自己不感興趣的活動也不是壞事，就算我對事情本身不感興趣，聽別人分享他們的興趣愛好也是很有意思的，有時更會讓我大開眼界。要是朋友不做我沒有接觸過的事情，反而沒有意義。\n不過，這只能讓我痛快地接受邀請而已，更重要的問題是，我能從其他人的角度考慮，主動邀請他們參加娛樂活動嗎？我不知道。如果連我也沒有辦法貫徹「保持聯繫」到底的話，那還有誰會呢？\n開誠布公 前面的理由都只是藉口而已，我知道要保持和朋友聯絡，就必須要發自內心地對他們的生活感興趣。\n很遺憾的是，要瞭解其他人的生活，就很難繞開社交網絡，但是我很害怕在社交網絡上觀看別人的生活，似乎只要疏遠了一段時間，對方就會變成我不認識的人，過着與我毫無關係的生活。我害怕看別人分享自己的生活，卻希望別人能讀我寫的文章。這樣不太公平吧？\n加上社交網絡是個毫不自由，讓人提心吊膽的地方。一是科技公司掌握着我的賬户的生殺大權，哪天我添加了太多朋友，系統就會認為我違反規定，把我的賬號停掉，抹殺我在網絡社會裏的存在；二是要在維持網絡形象和保護隱私之間走鋼索。我必須要用實名設賬號，不然就沒有人知道我是我，更不用説收穫名氣了，同時又不能暴露太多個人資訊，或留下會被人當作把柄的字句。\n要是能把別人在社交網絡上發的文章接到我的閲讀器裏就好了，這樣我會讀得輕鬆一點，但社交網站都很封閉，不一定允許我這樣做。我沒有解決這個問題的好辦法，只能先看我光憑通訊軟件能走多遠了。\n躊躇不決 就算我把煩惱想得清清楚楚，情況依舊沒有改變。似乎我應該做一套督促自己找人聊天的遊戲化系統，不過這很明顯不是問題的關鍵。在那之前，我更應該頻繁地在這裏分享自己正在做的事，草稿也好，半成品也好，至少我要做好這種單向的交流。\n","date":"2024-12-25T07:36:05+08:00","permalink":"https://evthron.github.io/zh/posts/contact-friends/","title":"和朋友保持聯絡"},{"content":"Link \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css\u0026#34; integrity=\u0026#34;sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; referrerpolicy=\u0026#34;no-referrer\u0026#34; /\u0026gt; integrity crossorign referrerpoily link stylesheet\nHTML Original \u0026lt;div class=\u0026#34;progress-bar bg-blue\u0026#34; role=\u0026#34;progressbar\u0026#34; style=\u0026#34;width: 97%\u0026#34; aria-valuenow=\u0026#34;10\u0026#34; aria-valuemin=\u0026#34;0\u0026#34; aria-valuemax=\u0026#34;100\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Modified \u0026lt;div class=\u0026#34;progress-bar\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress-experience\u0026#34; style=\u0026#34;width: {{ .Get `percentage`}}\u0026#34; role=\u0026#34;progressbar\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; CSS .progress-bar{ display: -webkit-box; display: -ms-flexbox; display: flex; height: 1rem; overflow: hidden; font-size: 0.75rem; background-color: hsl(210, 16%, 93%); border-radius: 0.25rem; width: 50%; } .progress-experience { display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: normal; -ms-flex-direction: column; flex-direction: column; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; color: #fff; text-align: center; background-color: #007bff; transition: width 0.6s ease; background-image: linear-gradient( 135deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent ); background-size: 1rem 1rem; } Modified: .progress-bar{ display: flex; height: 1rem; font-size: 0.75rem; border-radius: 0.25rem; width: 50%; background-color: hsl(210, 16%, 93%); /* important */ overflow: hidden; } .progress-experience { display: flex; justify-content: center; color: #fff; text-align: center; background-color: #007bff; transition: width 0.6s ease; background-image: linear-gradient( 135deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent ); background-size: 1rem 1rem; } Unknown aria\n-webkit-box \u0026ndash; web references -ms-flexbox; -webkit-box\nbox-orient = flex-direction (row, column) box-pack = align right center left box-direction = rtl ltr ttb btt\n","date":"2024-12-23T09:27:45+08:00","permalink":"https://evthron.github.io/zh/code/cobalto.dev/","title":"cobalto.dev"},{"content":"Example Tree mapping conversion tree = {\u0026#34;servant\u0026#34; : {\u0026#34;saber\u0026#34; : {\u0026#34;excalibur\u0026#34; : {}}, \u0026#34;archer\u0026#34; : {\u0026#34;ubw\u0026#34; : {\u0026#34;Caladabolg\u0026#34; : {}}}, \u0026#34;lancer\u0026#34; : {\u0026#34;gae_bolg\u0026#34; : {} }}} mapping = {\u0026#34;saber\u0026#34; : \u0026#34;shirou\u0026#34;, \u0026#34;archer\u0026#34; : \u0026#34;rin\u0026#34;, \u0026#34;lancer\u0026#34; : \u0026#34;unknown\u0026#34;, \u0026#34;servant\u0026#34; : \u0026#34;holy_grail\u0026#34;, \u0026#34;excalibur\u0026#34; : \u0026#34;beam\u0026#34;, \u0026#34;ubw\u0026#34; : \u0026#34;sword\u0026#34;, \u0026#34;Caladabolg\u0026#34; : \u0026#34;Broken Phantasm\u0026#34;, \u0026#34;gae_bolg\u0026#34; : \u0026#34;lucky E\u0026#34;} def get_new_tree(tree): new_tree = {} for servant, subtree in tree.items(): master = mapping[servant] new_tree[master] = get_new_tree(subtree) return new_tree print(get_new_tree(tree)) 把 notebook id 轉換成有實際內容的 notebook item 從 dict 變成了 list 結構 把 dictionary Tree 改造成 TreeItem tree，每個端點可以儲存 list。TreeItem 是 改造後的 dictionary class 這也是 Post-order traversal嗎？從最底層開始建立新的 Tree def replace_ids_by_items(id_tree): item_tree = [] # 從頂層開始，把一層的 Tree Node 加入 item Tree for key, value in id_tree.items(): # 需要呼叫 api 才能獲取所有的 child。 child_notes = api.get_all_notes(notebook_id=key, fields=\u0026#34;id,title,body\u0026#34;) # 每有一個 id tree 元素，就要在 item_tree 裏放入一個元素。 item_tree.append( # TreeItem 包含子 notebook data # child\u0026#39;s child_tree （用遞歸的方式獲取） # child\u0026#39;s notebook （id, title 和 body）和 resources TreeItem( # 取用外層的 notebook_flat_map 值 notebooks_flat_map[key], # notebook_data replace_ids_by_items(value), # child_items，value 指 child id_tree child_notes, ) ) return item_tree key 是 notebook，notebooks_flat_map[key] 是 notebook 的 data value 是 child id_tree，所以要用 replace_ids_by_items 轉換成 item_tree 底層：value 是空的 dict，傳回空的 list Example Tree mapping conversion\ndef create_notebook_tree(flat_list): # 創建空白的 graph graph = {item: set() for item in flat_list} roots = [] for id_, item in flat_list.items(): parent_id = item.parent_id # 如果 child 有 Parent，就把 child 加進 Parent if parent_id: graph[parent_id].add(id_) else: # 如果沒有 parent_id，就等於 root roots.append(id_) 為 Parent List 轉換 Graph 創建空白的 graph\ngraph = {item: set() for item in flat_list} import argparse from pathlib import Path from joppy.api import Api def main(): args = parse_args() api = Api(token=args.api_token) # Tree 是 notebook tree，以 list 的形式儲存。 tree = create_hierarchy(api) create_files(api, tree, Path(args.output_folder)) 把 Tree 轉換成檔案結構 \u0026ndash; flashcards 把 Tree 轉換成檔案結構\nBuild folder for itself tell the child to run this function(create all the directories) output the files (make files after all the directories have been build) def create_files(api, tree, output_dir: Path): output_dir.mkdir(exist_ok=True) for item in tree: current_directory = output_dir / replacements(item.data.title) # Post order traversal # 先幫自己創建 output_dir，然後叫自己的 children notebook 自己幫自己創建 current_directory # 真正的第一層是外部提供的地址，不在樹裏面，所以有點彆扭，不過之後的每一層都可以這樣想。 # 底層：item.child_items 是空的，沒有 children，幫自己創建完畢後就結束。 create_files(api, item.child_items, current_directory) # 要先建立好 directory 才能放進筆記 # 每一層的筆記本要創建自己的筆記，從最底層開始。 for note in item.child_notes: with open( (current_directory / replacements(note.title)).with_suffix(\u0026#34;.md\u0026#34;), \u0026#34;w\u0026#34; ) as outfile: outfile.write(note.body) # 創建 Resources，不重要 for resource in item.child_resources: resource_binary = api.get_resource_file(id_=resource.id) # 輸出 bianary file 的方法 with open( current_directory / replacements(resource.title), \u0026#34;wb\u0026#34; # write binary ) as outfile: outfile.write(resource_binary) 把 Tree 轉換成檔案結構 \u0026ndash; flashcards 把 Tree 轉換成檔案結構 例子：\nfrom pathlib import Path desktop_path = Path(\u0026#34;C:\\\\Users\\\\Jacky\\\\Desktop\\\\Test\u0026#34;) def output_to_desktop(tree : dict, output_dir : Path): output_dir.mkdir(exist_ok=True) for parent, child in tree.items(): new_path = output_dir / parent output_to_desktop(child, new_path) Replace bad characters in filenames https://stackoverflow.com/a/27647173/7410886\ndef replacements(value: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Replace bad characters in filenames.\u0026#34;\u0026#34;\u0026#34; return re.sub(r\u0026#39;[\\\\/*?:\u0026#34;\u0026lt;\u0026gt;|\\s]\u0026#39;, \u0026#34;_\u0026#34;, value) 製作從 id 到 item 的 Mapping (item 包含 parent id，所以是 Parent list)\n製作 id Parent list (api 得到的 item 包含 parent id） parent list 變成 graph graph 變成 tree (需要 hierarchy recursion) id tree 變成 item tree （需要 recursion） def create_hierarchy(api): notebooks_flat_api = api.get_all_notebooks(fields=\u0026#34;id,title,parent_id\u0026#34;) notebooks_flat_map = {notebook.id: notebook for notebook in notebooks_flat_api} notebook_tree_ids = create_notebook_tree(notebooks_flat_map) item_count = defaultdict(int) # 共享外面的 item_count # ID Tree 變成 item tree def replace_ids_by_items(notebook_tree_ids): ...\tnotebook_tree_items = replace_ids_by_items(notebook_tree_ids) return notebook_tree_items Parent Graph 和 edge List 的區別 edge graph 不能從 edge list 輕鬆找到沒有 Parent 的元素。\ngraph = {[]} has_parent = {node : False for node in node_list} for start, end in edge_graph: graph[start] = graph.get(start, []}.append(end) has_parent[end] = True # 建立資料結構的方法 @dataclass class TreeItem: \u0026#34;\u0026#34;\u0026#34;Represents a notebook and its children.\u0026#34;\u0026#34;\u0026#34; data: dt.NotebookData child_items: List[TreeItem] child_notes: List[dt.NoteData] child_resources: List[dt.ResourceData] with open( current_directory / replacements(resource.title), \u0026#34;wb\u0026#34; # write binary ) as outfile: outfile.write(resource_binary) # 原本的資料結構： directed graph ，只有 edges。 # 轉換成 Neighbour Graph Convert edge graph to neighbour graph\nFind the roots\nmake the tree from the roots.\n建立 Graph，node : set()\n用 has parent dict，預設 False，檢查所有 node。\n如果 has_parent 等於 False，就把端點加入 roots。\ndef convert_edge_graph_to_neightbour_graph(edge_graph): graph = { parent : set() for parent, child in edge_graph.keys()} check_has_parent = { parent : False for parent, child in edge_graph.keys()} for parent, child in edge_graph.keys(): check_has_parent[child] = True graph[parent].add(child) roots = [ node for node, has_parent in check_has_parent.items() if not has_parent] def create_notebook_tree(flat_list): graph = {name: set() for tup in lst for name in tup} has_parent = {name: False for tup in lst for name in tup} for parent, child in lst: graph[parent].add(child) has_parent[child] = True roots = [name for name, parents in has_parent.items() if not parents] ","date":"2024-12-23T09:27:45+08:00","permalink":"https://evthron.github.io/zh/code/custom_export/","title":"custom_export"},{"content":"\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt; Sticky Sidebar\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;sticky.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;p\u0026gt; This is sidebar\u0026lt;/p\u0026gt; \u0026lt;figure class=\u0026#34;avatar\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/img1.jpg\u0026#34; class=\u0026#34;icon\u0026#34; alt=\u0026#34;avatar\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;emoji\u0026#34;\u0026gt;❤\u0026lt;/span\u0026gt; \u0026lt;/figure\u0026gt; \u0026lt;div class=\u0026#34;menu-items\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt; button 1\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt; button 2\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Illo, reiciendis dolore? Dignissimos nesciunt id facilis expedita? Ratione voluptatibus atque quaerat nobis sed quo eveniet libero, et, esse, veritatis hic voluptatum.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Officiis, ad veritatis! Quisquam culpa inventore, vel magnam qui alias quia temporibus unde, voluptates soluta corrupti quasi. Mollitia repudiandae quae laborum ea!\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Enim exercitationem reiciendis fugiat, fuga placeat similique architecto quasi est consequuntur rerum nam. Laboriosam aperiam distinctio aspernatur, ipsam repellat aliquid suscipit a?\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; body{ margin: 0 0 0 0; } header{ top: 0; position: sticky; background-color: blueviolet; } .container{ background-color: azure; display: flex; flex-direction: row; height : 200vh; } .sidebar{ position: sticky; background-color: aqua; height: 100vh; width: 20rem; display: flex; flex-direction: column; top: 0; align-items: center; /*沿垂直方向對齊*/ } .avatar{ position: relative; /*還是不知道為什麼要用 Relative*/ width: 5rem; height: 5rem; } .icon{ width: 5rem; height: 5rem; border-radius: 5rem; box-shadow: 10px 10px 10px #123456; } .emoji{ position: absolute; right: 0px; bottom: 0px; background-color: white; border-radius: 20px; width : 20px; height : 20px; } .menu-items{ display: flex; flex-direction: column; justify-content: center; width: 5rem; align-items: center; } .text{ display: flex; justify-content: center; width: 4rem; } /** * Slide up/down * Code from https://dev.to/bmsvieira/vanilla-js-slidedown-up-4dkn * @param target * @param duration */ let slideUp = (target: HTMLElement, duration = 500) =\u0026gt; { // 過渡時間是 2 秒 duration = 2000 // 在過渡的時候，為 target 多加一個 transiting element，表示正在過渡 target.classList.add(\u0026#39;transiting\u0026#39;); /// 設定哪些元素有過渡動畫 //target.style.transitionProperty = \u0026#39;height, margin, padding\u0026#39;; target.style.transitionProperty = \u0026#39;height\u0026#39;; target.style.transitionDuration = duration + \u0026#39;ms\u0026#39;; // 在 2 秒內把全部變成 0 target.style.boxSizing = \u0026#39;border-box\u0026#39;; target.style.height = target.offsetHeight + \u0026#39;px\u0026#39;; target.offsetHeight; target.style.overflow = \u0026#39;hidden\u0026#39;; target.style.height = \u0026#34;0\u0026#34;; target.style.paddingTop = \u0026#34;0\u0026#34;; target.style.paddingBottom = \u0026#34;0\u0026#34;; target.style.marginTop = \u0026#34;0\u0026#34;; target.style.marginBottom = \u0026#34;0\u0026#34;; // 完成過渡之後就去除特性 window.setTimeout(() =\u0026gt; { target.classList.remove(\u0026#39;show\u0026#39;) target.style.removeProperty(\u0026#39;height\u0026#39;); target.style.removeProperty(\u0026#39;padding-top\u0026#39;); target.style.removeProperty(\u0026#39;padding-bottom\u0026#39;); target.style.removeProperty(\u0026#39;margin-top\u0026#39;); target.style.removeProperty(\u0026#39;margin-bottom\u0026#39;); target.style.removeProperty(\u0026#39;overflow\u0026#39;); target.style.removeProperty(\u0026#39;transition-duration\u0026#39;); target.style.removeProperty(\u0026#39;transition-property\u0026#39;); target.classList.remove(\u0026#39;transiting\u0026#39;); }, duration); } let slideDown = (target: HTMLElement, duration = 500) =\u0026gt; { target.classList.add(\u0026#39;transiting\u0026#39;); target.style.removeProperty(\u0026#39;display\u0026#39;); target.classList.add(\u0026#39;show\u0026#39;); let height = target.offsetHeight; target.style.overflow = \u0026#39;hidden\u0026#39;; target.style.height = \u0026#34;0\u0026#34;; target.style.paddingTop = \u0026#34;0\u0026#34;; target.style.paddingBottom = \u0026#34;0\u0026#34;; target.style.marginTop = \u0026#34;0\u0026#34;; target.style.marginBottom = \u0026#34;0\u0026#34;; target.offsetHeight; ///target.style.boxSizing = \u0026#39;border-box\u0026#39;; target.style.transitionProperty = \u0026#34;height, margin, padding\u0026#34;; target.style.transitionDuration = duration + \u0026#39;ms\u0026#39;; target.style.height = height + \u0026#39;px\u0026#39;; target.style.removeProperty(\u0026#39;padding-top\u0026#39;); target.style.removeProperty(\u0026#39;padding-bottom\u0026#39;); target.style.removeProperty(\u0026#39;margin-top\u0026#39;); target.style.removeProperty(\u0026#39;margin-bottom\u0026#39;); window.setTimeout(() =\u0026gt; { target.style.removeProperty(\u0026#39;height\u0026#39;); target.style.removeProperty(\u0026#39;overflow\u0026#39;); target.style.removeProperty(\u0026#39;transition-duration\u0026#39;); target.style.removeProperty(\u0026#39;transition-property\u0026#39;); target.classList.remove(\u0026#39;transiting\u0026#39;); }, duration); } let slideToggle = (target: HTMLElement, duration = 500) =\u0026gt; { if (window.getComputedStyle(target).display === \u0026#39;none\u0026#39;) { return slideDown(target, duration); } else { return slideUp(target, duration); } } export default function () { const toggleMenu = document.getElementById(\u0026#39;toggle-menu\u0026#39;); if (toggleMenu) { // () =\u0026gt; {} 的意思是沒有 parameter，回傳 toggleMenu.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { if (document.getElementById(\u0026#39;main-menu\u0026#39;).classList.contains(\u0026#39;transiting\u0026#39;)) return; document.body.classList.toggle(\u0026#39;show-menu\u0026#39;); slideToggle(document.getElementById(\u0026#39;main-menu\u0026#39;), 300); toggleMenu.classList.toggle(\u0026#39;is-active\u0026#39;); }); } } ","date":"2024-12-23T09:27:45+08:00","permalink":"https://evthron.github.io/zh/code/hugo-theme-stack/","title":"hugo-theme-stack"},{"content":" Base API Base Methods Classes based on Base API User friendly methods python debug {{LOGGER.debug}} prints debug message\nLogging @static method double bracket (when the function returns a callable object) Type objects (Optional, Union) Requests (localhost) ** kwargs, use dictionary as keyword argument {dict}.get() as \u0026lsquo;if exist, else\u0026rsquo; 全部都是 _request 處理的，其他的 post, delete, get, put 只是指定 method\nLOGGER.debug prints debug message class ApiBase: \u0026#34;\u0026#34;\u0026#34;Contains the basic requests of the REST API.\u0026#34;\u0026#34;\u0026#34; def __init__(self, token: str, url: str = \u0026#34;http://localhost:41184\u0026#34;) -\u0026gt; None: self.url = url self.token = token def _request( self, method: str, # method 是 get / post / delete /put path: str, query: Optional[dt.JoplinKwargs] = None, data: Optional[dt.JoplinKwargs] = None, files: Optional[Dict[str, Any]] = None, ) -\u0026gt; requests.models.Response: LOGGER.debug( f\u0026#34;API: {method} request: path={path}, query={query}, data={data}, \u0026#34; f\u0026#34;files={files}\u0026#34; ) if data is not None and \u0026#34;id_\u0026#34; in data: # switch key id_ back to id? # \u0026#34;id\u0026#34; is a reserved keyword in python, so don\u0026#39;t use it. data[\u0026#34;id\u0026#34;] = data.pop(\u0026#34;id_\u0026#34;) if query is None: # init empty query safely, use None when Optional query = {} query[\u0026#34;token\u0026#34;] = self.token #turn dictionary to query items urs tring query_str = \u0026#34;\u0026amp;\u0026#34;.join([f\u0026#34;{key}={val}\u0026#34; for key, val in query.items()]) # saber=excalibur\u0026amp;archer=unlimited_blade_works try: # getattr 得到 method, get / post / delete /put ，所以能連續用括號。神祕的黑盒子...... response: requests.models.Response = getattr(SESSION, method)( f\u0026#34;{self.url}{path}?{query_str}\u0026#34;, # 提供 url json=data, files=files, ) LOGGER.debug(f\u0026#34;API: response {response.text}\u0026#34;) # 如果出錯，raise exception response.raise_for_status() except requests.exceptions.HTTPError as err: err.args = err.args + (response.text,) raise return response # joppy Delete, get, post, put ```python def delete(self, path: str) -\u0026gt; requests.models.Response: \u0026#34;\u0026#34;\u0026#34;Convenience method to issue a delete request.\u0026#34;\u0026#34;\u0026#34; return self._request(\u0026#34;delete\u0026#34;, path) def get( self, path: str, query: Optional[dt.JoplinKwargs] = None ) -\u0026gt; requests.models.Response: \u0026#34;\u0026#34;\u0026#34;Convenience method to issue a get request.\u0026#34;\u0026#34;\u0026#34; return self._request(\u0026#34;get\u0026#34;, path, query=query) #get 需要 query def post( self, path: str, data: Optional[dt.JoplinKwargs] = None, files: Optional[Dict[str, Any]] = None, ) -\u0026gt; requests.models.Response: \u0026#34;\u0026#34;\u0026#34;Convenience method to issue a post request.\u0026#34;\u0026#34;\u0026#34; return self._request(\u0026#34;post\u0026#34;, path, data=data, files=files) # post 需要 files 和 data def put( self, path: str, data: Optional[dt.JoplinKwargs] = None ) -\u0026gt; requests.models.Response: \u0026#34;\u0026#34;\u0026#34;Convenience method to issue a put request.\u0026#34;\u0026#34;\u0026#34; return self._request(\u0026#34;put\u0026#34;, path, data=data) # put 是什麼？ ","date":"2024-12-23T09:27:45+08:00","permalink":"https://evthron.github.io/zh/code/joppy-api/","title":"joppy-api"},{"content":" # Create a temporary directory for the resources. with tempfile.TemporaryDirectory() as tmpdirname: # Convert all notes to the specified format. os.makedirs(args.output_folder, exist_ok=True) for candidate in candidates: note = api.get_note(id_=candidate.id, fields=\u0026#34;body\u0026#34;) note_body = note.body title_normalized = ( candidate.title.lower().replace(\u0026#34; \u0026#34;, \u0026#34;_\u0026#34;) + \u0026#34;_\u0026#34; + candidate.id ) output_path = ( f\u0026#34;{args.output_folder}/{title_normalized}.{args.output_format}\u0026#34; ) extend a list generator Finding notes with certain title.\nBad version for note in notes: for title in args.note_titles: if note.title == title: candidates.append note Good version for title in args.note_titles: candidates.extend([note for note in notes if note.title == title]) ","date":"2024-12-23T09:27:45+08:00","permalink":"https://evthron.github.io/zh/code/note_export/","title":"note_export"},{"content":"def analyze_text(text: str):\ntokens = word_tokenize(text) tokens = [ # normalize to lower case word.lower() for word in tokens # exclude md syntax if word not in (\u0026#34;...\u0026#34;, \u0026#34;\u0026#39;\u0026#39;\u0026#34;, \u0026#34;``\u0026#34;, \u0026#34;--\u0026#34;, \u0026#34;++\u0026#34;) and # exclude punctuation word not in string.punctuation and # exclude single character words len(word) \u0026gt; 1 and # exclude words containing digit not any(character.isdigit() for character in word) #generator is allowed to be used in any() ] print(\u0026#34;Words:\u0026#34;, len(tokens)) # filter most common words tokens = [ word for word in tokens if word not in set(stopwords.words(\u0026#34;english\u0026#34;) + stopwords.words(\u0026#34;german\u0026#34;)) ] fdist = FreqDist(tokens) # fdist.plot(50) print(\u0026#34;Most common words:\u0026#34;) for word, count in fdist.most_common(10): print(f\u0026#34;- {word}: {count}\u0026#34;) exclude words that contains numbers \u0026ndash; flashcards\ndef check_word_contain_digit: return any(char.isdigit() for char in word) requirements for token lowercase word.lower() no single character words if len(word) \u0026gt; 1 No symbol no punctuation if word not in string.punctuation no markdown symbol (front matter +++ \u0026mdash;) if word not in [\u0026rsquo;+++\u0026rsquo;, \u0026lsquo;\u0026mdash;\u0026rsquo;, \u0026lsquo;', `--`, ++] no word has numbers if not any(c.is_digit() for c in word) tokens = word_tokenize(text) tokens = [ # normalize to lower case word.lower() for word in tokens # exclude md syntax if word not in (\u0026#34;...\u0026#34;, \u0026#34;\u0026#39;\u0026#39;\u0026#34;, \u0026#34;``\u0026#34;, \u0026#34;--\u0026#34;, \u0026#34;++\u0026#34;) and # exclude punctuation word not in string.punctuation and # exclude single character words len(word) \u0026gt; 1 and # exclude words containing digit not any(character.isdigit() for character in word) #generator is allowed to be used in any() ] print(\u0026#34;Words:\u0026#34;, len(tokens)) def analyze_text(text: str): tokens = word_tokenize(text) # tokens are all the words # reset tokens using list generator tokens = [ # normalize to lower case word.lower() for word in tokens # exculde punctuation if word not in (\u0026#34;...\u0026#34;, \u0026#34;\u0026#39;\u0026#39;\u0026#34;, \u0026#34;``\u0026#34;, \u0026#34;--\u0026#34;, \u0026#34;++\u0026#34;) and word not in string.punctuation and # exclude single character words len(word) \u0026gt; 1 and # exclude words containing less than one digit not any(character.isdigit() for character in word) # generator is allowed to be used in any() ] # show how many words are there print(\u0026#34;Words:\u0026#34;, len(tokens)) # filter most common words tokens = [ word for word in tokens if word not in set(stopwords.words(\u0026#34;english\u0026#34;) + stopwords.words(\u0026#34;german\u0026#34;)) ] # generate frequecy dictionary using FreqDist fdist = FreqDist(tokens) # fdist.plot(50) print(\u0026#34;Most common words:\u0026#34;) for word, count in fdist.most_common(10): print(f\u0026#34;- {word}: {count}\u0026#34;) ","date":"2024-12-23T09:27:45+08:00","permalink":"https://evthron.github.io/zh/code/note_stats/","title":"note_stats"},{"content":"HTML \u0026lt;!-- input number field --\u0026gt; \u0026lt;div class=\u0026#34;card_number\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;field\u0026#34;\u0026gt; \u0026lt;!-- keyboard shortcut button logo--\u0026gt; \u0026lt;!-- \u0026lt;kbd class=\u0026#34;field_hotkey\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;l\u0026lt;/kbd\u0026gt; --\u0026gt; \u0026lt;input class=\u0026#34;field_input\u0026#34; role=\u0026#34;spinbutton\u0026#34; /\u0026gt; \u0026lt;!-- increase arrow --\u0026gt; \u0026lt;!-- what is tab index? --\u0026gt; \u0026lt;button class=\u0026#34;field_control is-increase\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- decrease arrow --\u0026gt; \u0026lt;button class=\u0026#34;field_control is-decrease\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; CSS button{ cursor: pointer; //cursor change to hand } .card_number{ // What is inset-inline-end? inset-inline-end: 32px; width: 110px; border-radius: 5px; overflow: hidden; top: 20px; } .field{ position: relative; } .field_input{ // location // functional width: 100%; box-sizing: border-box; height: 40px; // aesthetic background-color: whitesmoke; border: none; // location of the cursor (inner space of the field); // updown = 0 // leftright = 12px padding: 0px 12px; } .field_input[role=\u0026#34;spinbutton\u0026#34;]{ padding-inline-end: 30px; text-align:right; } .field_control{ // location position: absolute; right: 0; // size height: 50%; width: 22px; // aesthetic border: none; // background-color: lightcoral; } .field_control.is-increase{ // location top: 0; right: 0; // aesthetic background-color: #ff95a6; transform: rotate(180deg); } .field_control.is-decrease{ // location bottom: 0; right: 0; // aesthetic background-color: #58c5ff; } .field_control:before { // function content: \u0026#34;\u0026#34;; position: absolute; // overlap on the button top: 1px; //gap betton the shapes // left: 50%; // size width: 12px; height: 12px; margin-left: -6px; // aesthetics background: white; border-radius: 0px 0 6px 6px; //staring from top-right, clockwise } .field_control:after { --width: 6px; position: absolute; top: 10%; left: calc(50% - var(--width) /2); right: 50%; width: var(--width); height: 6px; // margin-left: 50%; content: \u0026#34;\u0026#34;; background: url(\u0026#34;data:image/svg+xml,%3csvg%20xmlns=\u0026#39;http://www.w3.org/2000/svg\u0026#39;%20fill=\u0026#39;none\u0026#39;%20viewBox=\u0026#39;0%200%206%206\u0026#39;%3e%3cpath%20fill=\u0026#39;%23000\u0026#39;%20d=\u0026#39;M.707%201.825%202.62%204.057a.5.5%200%200%200%20.76%200l1.913-2.232A.5.5%200%200%200%204.913%201H1.087a.5.5%200%200%200-.38.825Z\u0026#39;/%3e%3c/svg%3e\u0026#34;); } ","date":"2024-12-23T09:27:45+08:00","permalink":"https://evthron.github.io/zh/code/oklch.com/","title":"oklch.com"},{"content":"app = Flask(__name__) port = int(os.environ.get(\u0026#34;PORT\u0026#34;, 5000)) app.run(host=\u0026#34;127.0.0.1\u0026#34;, port=port) @app.route(\u0026#34;/\u0026lt;int:progress\u0026gt;/\u0026#34;) def get_progress_svg(progress): template_fields = get_template_fields(progress) return render_template(\u0026#34;progress.svg\u0026#34;, **template_fields) @app.route(\u0026#34;/\u0026#34;) def redirect_to_github(): return redirect(\u0026#34;http://127.0.0.1:5000/50\u0026#34;) @app.route(\u0026ldquo;這裏是 relative link\u0026rdquo;) def 這裏放要執行的 function int:progress 可以接受 input\nFlask 讀取 Url query \u0026ndash; flashcards Flask 讀取 Url query @app.route(\u0026quot;/int:variable_name\u0026quot;)\nFlask 設定每個 URL 對應的 function \u0026ndash; flashcards @app.route(\u0026quot;\u0026quot;) def test():\nGet Url arguments try: request.args.get(\u0026ldquo;query\u0026rdquo;) except (TypeError, ValueError): pass\ndef get_template_fields(progress): title = request.args.get(\u0026#34;title\u0026#34;) try: scale = int(request.args.get(\u0026#34;scale\u0026#34;)) except (TypeError, ValueError): scale = 100 # Review marked # Special use of conditional progress_width = 60 if title else 90 try: progress_width = int(request.args.get(\u0026#34;width\u0026#34;)) except (TypeError, ValueError): pass return { \u0026#34;title\u0026#34;: title, \u0026#34;title_width\u0026#34;: 10 + 6 * len(title) if title else 0, \u0026#34;title_color\u0026#34;: request.args.get(\u0026#34;color\u0026#34;, \u0026#34;428bca\u0026#34;), \u0026#34;scale\u0026#34;: scale, \u0026#34;progress\u0026#34;: progress, \u0026#34;progress_width\u0026#34;: progress_width, \u0026#34;progress_color\u0026#34;: get_progress_color(progress, scale), \u0026#34;suffix\u0026#34;: request.args.get(\u0026#34;suffix\u0026#34;, \u0026#34;%\u0026#34;), } Special use of conditional progress_width = 60 if title else 90 ","date":"2024-12-23T09:27:45+08:00","permalink":"https://evthron.github.io/zh/code/progress-bar/","title":"progress-bar"},{"content":"Taskwarrior 是一個簡單不花俏，功能豐富的待辦清單軟件。我自己改裝了一下。\n第一是實現了性價比排序功能。這是模仿 Supermemo 裏的 tasklist 功能，可以每個任務估算時間和價值，然後按照價值除以時間，也就是性價比排序。\n首先在 taskrc 裏設定 UDA (User Defined Attributes，用户定義的屬性）分別是 Time， Value，和 Worth（= Value / Time）。\n# 不知道為什麼，要是把 Time 和 Value 和定義為 numeric type 的話，顯示就會延伸到小數後很多位。 uda.time.type=string uda.time.label=Time uda.value.type=string uda.value.label=Value uda.worth.type=numeric uda.worth.label=Worth 然後修改 report.list 的欄位，加入 Time, Value，和 Worth\ndefault.command=list # 輸入 task 的時候自動執行 task list，而不是 task next report.list.columns=id,start.age,entry.age,depends.indicator,priority,project,tags,recur.indicator,scheduled.countdown,due,until.remaining,description.count,time,value,worth report.list.labels=ID,Active,Age,D,P,Project,Tags,R,Sch,Due,Until,Description,Time,Value,Worth 最後是根據 worth，也就是性價比排序\nreport.list.sort=worth-,start-,due+,project+ 例子：\n\u0026gt; task add 買牛奶 time:60 value:30 # 買牛奶要花 60 分鐘 # 我覺得買牛奶對我來説值 30 元 # 顯示效果 ID | Active | Age | Description | Time | Value | Worth | 19 | | 1s | 買牛奶 | 60 | 30 | 0.500 | 要讓 taskwarrior 自動計算性價比，就需要用到 hooks，也就是自動和 taskwarrior 一起運行的程序。寫兩個 Shell Script，分別是 on-add.01.prioirty 和 on-modify.01.priority，一個在增加任務的時候執行，另一個在修改任務的時候執行。兩個 Shell Script 的內容是一樣的。\n#!/usr/bin/env bash TASK=$(\u0026lt;/dev/stdin) echo \u0026#34;$TASK\u0026#34; | python \u0026#34;$HOME/.config/task/hooks/priority.py\u0026#34; $@ 每次增加或者修改任務，任務就會以 JSON 的形式交給 priority.py 處理，計算任務的性價比。\nimport sys import json try: task = json.loads(sys.stdin.readline()) except json.decoder.JSONDecodeError: pass # worth calculation if \u0026#39;time\u0026#39; in task.keys() and \u0026#39;value\u0026#39; in task.keys(): task[\u0026#39;worth\u0026#39;] = str(\u0026#34;{:.3f}\u0026#34;.format(int(float(task[\u0026#39;value\u0026#39;])) / int(float(task[\u0026#39;time\u0026#39;])))) print(json.dumps(task)) 第二是我用了 task2hab (github) 這個插件，可以自動把 taskwarrior 的任務同步到 habitica 上。另外我還模仿了另一個插件 taskwarrior-habitica-bridge (github)，修改了一點代碼，讓完成任務的時候可以在終端裏顯示賺到的經驗和金幣。因為這個不是我寫的，我就不展開説了。\n","date":"2024-11-25T01:51:20+08:00","permalink":"https://evthron.github.io/zh/toolbox/taskwarrior-hooks/","title":"定製 Taskwarrior"},{"content":"我以前不太關心朋友的生活。如果關心他們的生活對我沒有好處的話，我就會覺得沒有意義，但如果是為了得到好處才去關心的話，我又會覺得自己很不真誠。直到我讀了 Getting Relationships Right 這本書之後，才發現我其實也是很渴望能和別人建立連繫的。我雖然害怕別人對自己的事情不敢興趣，不過如果他們真的能聽進去，我就會很驚喜；我雖然害怕聽到別人的生活比自己充實，但有時候也能從中發現一些讓我覺得很新奇的事情。關心別人是為了滿足我內心的感覺，而不是為了外在的利益，這是我交際的動力。\n我要陪朋友閒聊，發我不喜歡用的短信，參加我沒有興趣的聚會，和不認識的人搭話。不是為了得到知識（交換知識的聊天挑戰 ），也不是為了獲得幫助，而是為了互相了解大家的性格、興趣和目標。這是一件多麼冒險，多麼耗時，但又多麼好玩的事啊！\n","date":"2024-11-20T04:18:31+08:00","permalink":"https://evthron.github.io/zh/posts/reason-to-socialize/","title":"交朋友的理由"},{"content":"畫畫用的鉛筆要削得又長又尖，一般的削筆機是做不到的，只能用美工刀削。我削鉛筆的時削出來的碳粉跑進了玻璃桌上的刮痕，看起來很髒。\n在所有顏料裏，石墨的污漬似乎是最難處理的。大部分顏料的構造都是色素溶在溶劑裏，所以只要用適合的溶劑就能洗掉。但石墨的結構註定了它不會溶化，雖然很容易脱落，但總是會黏在某個地方，也永遠不會變質。\n雖然石墨不溶於水，但我還是用紙巾沾了點水才開始擦桌子。水把紙弄軟之後，才能深入縫隙。而且粉末卡在刮痕裏的時候，不能光在表面大範圍地擦拭，而是要用指甲頂着紙巾，和刮痕成垂直方向來回打轉，把碳粉帶出來，才能擦得乾淨。\n就在我擦得差不多，收拾東西的時候。我看見了橡皮擦。\n橡皮擦和鉛筆一樣，是畫家的武器，同樣也要好好削尖，才可以精細地擦除畫上要留白的地方。不要固執地只用磨圓了的部分。\n橡皮塊掉在了桌上。感覺有點浪費，可以用來做什麼呢？我的手指放在橡皮塊上推了一下。\n黑色的條紋完美地消失了。\n對啊！橡皮擦不就是專門拿來對付石墨的嗎？太久沒用鉛筆寫字讓我連這個簡單的原理都忘了嗎？\n仔細想想，橡皮擦還真是個偉大的發明。不僅可以改變形狀，接觸紙上不平整的地方，擦除痕跡之後沾滿石墨的部分還能自動脱落，脱落的團塊的體積足夠大，可以輕鬆用人手清理。在沒有橡皮擦的時代，鉛筆不就和墨水筆沒兩樣？\n","date":"2024-10-19T04:53:17+08:00","permalink":"https://evthron.github.io/zh/tweet/graphite-eraser/","title":"橡皮擦的妙用"},{"content":"電腦出了問題，我就會死纏爛打，絕不放棄，這種性格連我自己也感到很無奈。\n學校的作業要用到 Docker 開發網頁，把 Docker 想象成一個工具箱就可以。我發現網頁在 Docker 裏面連不上網，功課做不成了。很不巧，我用的是 Arch Linux。一般人用的操作系統不是 Windows 就是 MacOS。但 Arch 是要自己逐步把一個個組件拼起來的操作系統。好處是無論系統出了什麼問題都可以自己修理，壞處是會遇到很多一般人根本不會遇到的問題，可以説是作繭自縛。\n作業裏要連接外部網站的是一個 PHP 程式，是不是程式出錯了？老師給的程序應該不會錯，我對 PHP 又是一竅不通，隨便找了個網站的例子改了改程式碼，沒用。\n仔細看看網站報了什麼錯，\u0026lsquo;Temporary failure in name resolution\u0026rsquo;，DNS 出問題了。想必是因為我裝了個奇怪的 dnsmasq，雖然很危險但沒辦法只好暫時停用了。沒用。\n那麼是 Docker 的問題嗎？我對 Docker 也是一竅不通。説到底，這門課也用不着我們懂。本來只是輸一行 docker compose up 的事，裏面發生什麼事情完全不用管。唉，沒辦法，我還是學了一下 Docker 的運作原理。Docker 可以克服不同電腦甚至操作系統之間水土不服的問題，把開發環境連網站打包成容器 (Container），就哪裏都可以用。原來如此!我還自作聰明地把 Dockerfile，也就是設定檔裏的一行 apt-get 刪掉了呢。 Arch 上下載軟件的工具是 pacman，不是 apt。但只要設定好開發環境裏用 Apache，就沒問題。我把 Container 刪了再重建，沒用。\n我慌了，這還不夠嗎？看來是網絡設定問題，這就很麻煩了，可以出錯的地方太多了。安裝 Arch 的時候，設置網絡是最頭疼的部分。光説軟件層面已經有一大堆能把人搞糊塗的概念：網絡接口、網絡管理器、主機、IP 地址、端口、域名、DNS、防火牆。如果是 Docker 要調整內部的網絡設定，那就要弄官方文檔上説的什麼「端口轉發」，我一點也看不懂。\n總之先上網找找看。最好先排除學校給的容器有問題的情況。原來只要一句就可以調試 Docker 網絡。 docker run busybox ping google.com，借一個叫 busybox 的開發環境，向google 發一個乒乓球，看看對方會不會傳球回來。沒反應，丟包率 100%。\n網上的答案都説是 docker 是 DNS 設定出錯了。沒有辦法把 google.com 翻譯成真實的 IP 地址。要手動把 docker 的 dns 服務器改成 8.8.8.8，也就是 Google 提供的 DNS 服務器。一樣沒用。\n/etc/docker/daemon.json { \u0026#34;dns\u0026#34;: [\u0026#34;8.8.8.8\u0026#34;] } 這時我想起來，直接 ping IP 地址就可以排除 DNS 服務器的影響了。docker run busybox ping 127.0.0.1，這次成功，確認了 Docker 可以連上自家主機。然後是docker run busybox ping 8.8.8.8，但一樣不管用。\n説不定是防火牆的問題，乾脆關掉，沒用。我連防火牆軟件都試着從 ufw 換到 firewalld，還是沒用。\n這下就徹底沒辦法了，只能像無頭蒼蠅一樣在各大論壇遊走碰運氣。Arch wiki，Gentoo wiki，當然少不了 StackOverFlow。解決方法有一大堆，就是沒一種管用。別問我是什麼意思，我也不知道。按指示執行自己看不懂的步驟可是操作電腦的基本功。\nArch wiki 在 /etc/docker/daemon.json 設定：\nhttps://wiki.archlinux.org/title/Docker#Starting_Docker_breaks_KVM_bridged_networking { \u0026#34;iptables\u0026#34;: false } Gentoo wiki https://wiki.gentoo.org/wiki/Docker#Networking\n在 /etc/sysctl.d/local.conf 裏設定：\nnet.ipv4.ip_forward=1 改 docker-compose.yaml https://stackoverflow.com/questions/33780947/not-able-to-connect-to-network-inside-docker-container\nservices: worker: build: . network_mode: host #added here 使用主機的網絡 這個辦法是有效的，繞過了問題，但好像不能和 docker compose 一起用。 https://stackoverflow.com/a/5626362\ndocker run busybox --network=\u0026#34;host\u0026#34; ping google.com Windows 式修理法 https://stackoverflow.com/a/68474595\nsudo systemctl restart docker reboot nftables flush https://bbs.archlinux.org/viewtopic.php?id=277653 https://bbs.archlinux.org/viewtopic.php?id=277638\nsudo nft flush ruleset sudo pacman -R nftables 搞了這麼久，真的感覺自己在浪費時間，趕緊換到 Windows 弄 WSL (Windows Subsystem of linux）或者直接在 Linux 上裝虛擬機肯定會比較快。但我只要一被麻煩纏上就沒有心情思考其他的解決辦法。我説不定是在追求柳暗花明的感覺。\n幸好，36 個字節真的可以改變改變命運，答案其實就藏在同一條問題的深處。 https://stackoverflow.com/a/70452290\nsudo systemctl disable nftables sudo systemctl stop nftables sudo reboot 我明明已經解除安裝 nftables 了，是沒有重啓，還是因為再下載了要用到 nftables 的 firewalld 呢？總之現在再試 docker run busybox ping google.com 成功了！PHP 程式也順利拿到了網站的 JSON 檔案。真的高興得要拍手慶祝。\n搞了半天，我學會什麼了呢？重新温習了一遍 Arch 的上網設置，放棄了原本已經調整好的 dnsmasq，還知道了 nftables 和 iptables 有着神秘的關係。一天就這樣過去了。\n","date":"2024-10-17T19:37:47+08:00","permalink":"https://evthron.github.io/zh/posts/docker-panic/","title":"docker 連不上網的解決辦法和折騰的悲哀"},{"content":"我放假就像個廢人一樣，要花好幾天的心情調整心態，才有開始做事的決心。但時間不等人，截止日期的壓力會逼我做該做的事，既然這樣，一開始就不要放假好了。要做的事堆積如山，我卻提不起勁，這實在很令人煩躁。比起電腦燒掉和錯過考試，這算不上什麼，但因為這種雞毛蒜皮的小事而煩躁，實在令我很煩躁。看吧，這就是個走不出來的怪圈。\n哭過一場之後，我突然就很想坐下來寫這篇感想了，簡直毫不費力。無法否認，所謂的狀態好壞，比起心理準備，其實更受身體的影響。\n眼白白看着溜掉的光陰的光陰，是不會回來的沉沒成本，但心情是學不會經濟學的，保持自己情緒一致比什麼都來得重要，就算能像切換計算機模式一樣，按幾個按鈕就能平復情緒，也只會讓我感到很可悲。\n要憑理性控制情緒是很困難的，畢竟情緒的判斷是一瞬間的事，也有化學物質的干涉。不過，情緒不是沒有根據的東西。我們是從經驗判斷自己要表露出什麼情緒的。能説出「此壺已破，看它何用」的人肯定打破了幾十個壺。寫到這裏又開始困了。要乾脆地承認一天什麼都沒做？還是電腦前死死掙扎？這也是個艱難的選擇。因為我每次都會選擇掙扎，所以睡覺總是個更好的決定。\n","date":"2024-10-16T01:51:46+08:00","permalink":"https://evthron.github.io/zh/tweet/bad-mood-holiday/","title":"假期的壞心情"},{"content":"地鐵上，大家的握手機姿勢各種各樣：單手小指頂着機底，拇指滑屏幕；左手手掌捧着機背，右手食指滑屏幕；雙手在機背交疊，兩隻拇指在屏幕上快速敲擊；還有雙手抓着橫置的手機兩側，兩隻拇指在屏幕上劃圈。加上我的觀察角度也變來變去，有時是瞄旁邊的座位，有時是抬頭看坐在我正對面的人，或是側着身子抓把手的人。居然有種「橫看成嶺側成峯」的感覺。\n這個時候，我作為列車上唯一一個不想看手機的人，該做什麼才能消除盯着玻璃窗做白日夢的煩悶呢？就是把這些形態各異的手掌全部描在紙上，做一本手掌合輯。\n要盯着陌生人看肯定是不自在的。所以我會使用一些技巧。豎起本子，不能讓別人看見自己的畫紙；挑選離自己很遠的目標；不要一邊盯着人看一邊畫，要記住影像才在紙上動筆等等。不過這些技巧其實都不重要，最大的功臣還是手機。雖然我不太樂見，但正正是因為大家都無暇顧及手機之外的事物，我才有可乘之機。\n手掌合輯畫膩了，就改畫球鞋合輯，再接着畫髮型合輯。「列車上有數不清的模特兒站着不動讓我畫，真是個理想的畫室！」但他們隨便翻一下手掌，轉一下頭，我就只能傻傻地盯着紙上的半成品了。沒什麼好抱怨的，畢竟世界的一切景象本來就是稍縱即逝的。不僅落筆要快，萬一目標下車了，就要找另外一個姿勢相似的目標拼接起來。\n就這樣，我練就了一項無人能及的功夫：筆走龍蛇如入無人之境；目所能及之處，皆是素材。\n","date":"2024-10-13T04:48:32+08:00","image":"https://evthron.github.io/zh/posts/drawing-on-train/drawing-on-train_hu1463046701529252535.jpg","permalink":"https://evthron.github.io/zh/posts/drawing-on-train/","title":"地鐵畫畫"},{"content":"我被理髮師抱怨，説我的需求不清楚，真不幸。以前還不是一直都含糊其詞，剪出來的都差不多啊。唉，至少我現在會説理髮師聽得懂的話了。\n","date":"2024-09-18T23:57:07+08:00","permalink":"https://evthron.github.io/zh/tweet/haircut/","title":"理髮"},{"content":"第一章 基礎知識 井字棋是一種風靡全世界的遊戲，又名「過三關」，「圈叉棋」。井字棋的規則連小孩子也能明白，卻有着十變百化的局面，使人樂此不疲。\n一、遊玩方法 井字棋不需要棋盤。在白紙上劃兩條豎、兩條橫線（圖一）就可以玩。這個遊戲裏有兩種棋子 O 和 X，雙方各執一種棋子，先手用 O，後手就用 X；先手用 X，後手就用 O。在格子裏畫下自己的棋子叫作「下子」。誰先手誰後手由玩家自行協商，一般都是用剪刀石頭布決定。\n_|_|_ _|_|_ | | 圖一，井字棋的格子 二、勝利方法 自己的棋子沿着橫方向，三個連成一線 自己的棋子沿着豎方向，三個連成一線 自己的棋子沿着對角方向，三個連成一線 井字棋的初學者常常會忽略對角方向的連線，讓對手有可乘之機。只要細心觀察，判斷井字棋的局面其實是很簡單的。\n這些勝利條件很多時候會是會同時生效的。互相交錯的棋子和難以預測的局面，是井字棋的樂趣所在。\n三、記錄棋局 井字棋用一連串的座標記錄棋局。要玩好井字棋，一定要好好學習棋譜，所以我們要先瞭解井字棋的座標是怎樣定義的。橫行從上至下叫1、2、3，縱列從左到右叫a、b、c。我們根據格子在哪一行哪一列，為這個格子安上名字。例如，中間格在第二行第二列，就叫作 b2。\n一場棋局的棋譜看起來是這樣的：a1, b1, a3, a2, c3, b2, b3。先手在這場棋局（圖二）裏施展了一次著名的三角殺法。\na b c 1|O X 2|X X 3|O O O 圖二，先手使用了三角殺取得勝利 因為棋盤可以旋轉，相似的棋局會有多一種編碼。為了消除重複的編碼，讓棋譜更容易分析。編寫棋譜的時候會按照開局的第一步調整。\n下在了角，那個位置就是 a1。 下在了邊，那個位置就是 b1。 下在了中間格 b2，就由第二步決定座標，下在了角就是 a1，邊就是 b1。 四、攻擊和防守 下子之後，只差一子就連成一線，這次下子就是一次攻擊，也叫作「喊殺」。下子之後，使對方無法落下第三子，這就是一次防守。井子棋的先後手有着明確的區別：先手能頻繁地進攻，主導着棋局的發展，而後手就要不斷地防守，試圖抓住先手的破綻。知道了以上這些，你就可以開始玩井字棋了，不用着急看接下來的部分。第二章會更詳細地説明與攻擊和防守有關的關鍵概念。\n第二章 關鍵概念 一、殺法 你喊殺我就擋，再喊我就再擋，一來一回，似乎雙方只會持續着拉鋸戰，都沒有取勝的辦法。要打破這個僵局，就要説到「殺法」這個概念了。井字棋最為精妙之處，就是能夠下一次子，形成多條殺路。這樣一來，對手就沒有招架的辦法。構建殺法一般需要三條殺路，對手有機會阻擋兩條殺路，只會留下一條能夠取勝的路線。殺法可以根據這三枚棋子的位置分成三種：三角殺、中邊角殺和角邊角殺。\n二、反制 反制，是在防住對手攻擊的時候同時喊殺，迫使對手浪費一次構建殺局的機會來防禦，是後手扭轉局勢的唯一辦法。\n第三章 實戰 開局是先手在一場比賽裏最重要的決定。開局分為三種，中開，邊開，角開。每一種對應不同的戰略。 角開是最適合新手的開局，能夠使用三角殺，快速擊敗缺乏經驗的對手。中開是非常穩定的開局，下子的對稱性能夠大副減少需要思考的可能局面，而且能夠往四方八面連線，殺法眾多，局面豐富。有助新手練習推演能力。邊開是最弱的開局，基本不可能取勝，只有在高手的對決中能當成奇策。\n角開 角開是最簡單的開局，能夠迅速構建三角殺。三角殺需要的是 a1、a3、c1 三個角落，形成形成橫豎斜三條殺路。這個開局的明顯缺陷是放棄了關鍵的中間格。只要被有經驗的對手佔據中間格 b2，擋住斜路，就能被輕易破解。所以角開又被稱為「新手開局」。不需過多的分析，輸贏就看對手能不能看穿自己的意圖。\n從這個新手開局裏，我們發現井子棋的中間格是兵家必爭之地，佔據了中間格，就算不能勝利，也能掌控局面。為何不一開始就下在中間格呢？接下來就要説到最常用的中開了。\n中開 井字棋的棋盤設計，使得棋手佔領中心，才能形成橫、豎、斜三路（三角殺除外）。所以，先手開局「搶中」，是常見的做法。 中開的局面變化多樣，可使用多種殺法，如中邊角殺和角邊角殺。適合進階的棋手使用。\n這個開局追求的是中邊角殺。中邊角殺還細分成直角三角形式（a1, a2, b2） 和等腰三角形式（a1, b2, a3）。要採用那種形式，要按照對方的應對決定。中邊角有兩點要注意，第一是要熟記兩種形式的形狀，第二是要注意不要給對方反制的機會，必須更注重防禦。在角開裏，後手是沒有取勝的機會的，但在中開裏，對手可以埋伏好角角邊殺反擊。經驗不足的棋手容易出錯，使後手有反敗爲勝的機會。\n一、對方使用邊擋（b1） 這是比較缺乏經驗的對手。無論是直角三角形式還是等腰三角形式都可以。直角三角形式比較單純，只要在第 2 行的橫線進攻，再在第 3 行佔據一個角。就能順利使出中邊角殺。等腰三角形式就要注意不要給對方反制的機會。下在第 1 行的角沿斜線進攻，再在第 3 行的角進攻就完成了。\n二、對方使用角擋 (a1) 面對角擋，絕對不能使用直角三角形式。因為對方可以使用角邊角殺（a1, c2, c1）反殺。角邊角殺只需要橫和豎兩條殺路，是比較少見的殺法。就算是使用等腰三角形式，對方也一樣有反制的機會。井字棋中有名的「自動平手」局面，也是在這裏出現的：b2, a1, b3, b1, c1, a3, a2, c2, c3。雙方陷入了不斷反制的局面，被迫打成平手。\n中開的平手頻率是很高的，尤其雙方都對對方的進攻手段很熟悉的時候，在常見在賽制下，例如七局四勝制下，如果雙方都只使用中開，很容易僵持不下。為了在高手之間的對決中勝出，就要説到一個被很多人忽略的開局，也就是邊開了。\n邊開 邊開是最弱的開局，對新手來說幾乎不可能獲勝。先手只有唯一一個勝機。一旦對手下在了於自己不相交的邊，即 a2 或 c2。下在不相交的邊是井字棋的一個難以注意到的錯誤。這不能妨礙對方繼續構建殺法，相當於放棄了一次防禦機會。由於這個開局相當少見，後手判斷錯誤也是有可能的。\n一旦對方放棄了防禦，就能輕易搶回中心，讓局勢回到「中開」後下邊的局勢（b2，b1），然後使用「中開」的策略，用 a1 位置構建中邊角殺。\n這個開局把主動權讓給了對手。在井字棋中，多數的後手習慣使用防禦戰術逼和，先手露出空隙的情況少之又少。先手讓子，反而有出奇制勝的機會。\n結語 要玩好井字棋並不容易，無論輸掉多少次也絕對不要氣餒。任何一個井字棋玩家，都是要經過數小時的鑽研，才能成為大師的。最重要的，還是不要執着於勝負，好好享受在賽局中思考每一步棋的樂趣。畢竟當你知道了一個遊戲的必勝法，不用思考就能下決定，這個遊戲對你來説就死了。你是要沉迷於這輕易取得的勝利，還是要看向下一個新遊戲，再次感受殺掉遊戲的快樂呢？\n","date":"2024-09-15T23:39:01+08:00","permalink":"https://evthron.github.io/zh/posts/tic-tac-toe/","title":"井字棋入門"},{"content":"我為什麼要莫名其妙地研究什麼「量數和序數」呢？這是因為我搞不懂中位數的公式。統計學課本上都寫着，是 (n+1)/2，n 是數字的總數。公式很簡單，但卻很難理解。為什麼要先加一再除以二？你可能會説，管它那麼多幹嘛，套公式就完了。但是，二分查找法1也要用到中位數，但公式變成了 (n - 1)/2，這似乎和編程語言從零開始編號的做法有關。兩者的差異使我如鯁在喉，這個問題又不需要特殊的數學知識，為了以後寫二分查找法的時候不會出錯，我接下了這個挑戰。\n歸根究底是這個問題：為什麼五个蘋果平分是 2.5 個，但五根手指的中間是第三根呢？這就是量數和序數的不同。想象你在一排路燈旁邊散步。路燈從一到五編好了號。從一號路燈走到五號路燈需要四步，用數式表示是這樣的：\n一號 + 四步 = 五號 起點編號 + 步數 = 終點編號 移項得到：\n四步 = 五號 - 一號 步數 = 終點編號 - 起點編號 如果從 1 開始編號，步數 = 終點編號 - 1。 這裏的編號就是序數，可以看到，序數相減能變成步數。步數是量數，有加減乘除。這就是我原創的「序數運算」。數學家用序數研究什麼是「無限+1 (Youtube)」，我用序數研究小學數學，這下我也當了一回「民間數學家」了。\n現在回到中位數的問題。中位數是用來切開數列的一把刀，左右兩邊的數字數量相等。例如數列 56789，排在第三位的7就是中位數。要找到中位數，就要先知道中位數排在第幾位。用路燈的比喻思考，從起點走到中間路燈的距離，等於從中間路燈走到盡頭的距離。這是「中間」的定義，所以：\n起點編號 + 總步數 ÷ 2 = 中位數編號 展開「總步數」：\n起點編號 + （終點編號 - 起點編號）÷ 2 = 中位數編號 （起點編號 + 終點編號）÷ 2 = 中位數編號 這下公式的意義就很明確了，統計學和編程的差異也一目瞭然。正常人從一開始編號，總數 n 就是終點編號，所以中位數公式是 (1 + n) ÷ 2，而程序員從零開始編號，終點編號變成了 n - 1，所以中位數公式是 (0 + n - 1) ÷ 2。\n聽着似乎很彆扭，為什麼偏偏要從零開始數？我來稍微解説一下。編程和統計學不一樣，不太不關心總數，編號反而更有用，所以我們遇到的 n 往往是終點編號。這樣一來，中位數公式就成了簡單的 n / 2。\n這裏附上簡單的二分查找的説明。我們要從一串數字裏找到 10，這些數字已經按大小編好了號，當然是從零開始編。\n數字：0 2 4 10 15 編號：0 1 2 3 4 頭 尾 第一個中點是 0 + (4-0)/2 = 2。\n數字：0 2 4 10 15 編號：0 1 2 3 4 頭 中 尾 編號 2 的數字是 4，比 10 小，所以接着把中點設成起點。\n數字：0 2 4 10 15 編號：0 1 2 3 4 頭 尾 第二個中點是 2 + (4 - 2) /2 = 3\n數字：0 2 4 10 15 編號：0 1 2 3 4 頭 中 尾 編號 3 的數字是 10，找到收工。\n編程術語，一種從數列中搜尋數字的流程\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-09-12T03:35:28+08:00","permalink":"https://evthron.github.io/zh/posts/median/","title":"中位數公式"},{"content":"總算遷移到了 Linux 系統。本來想在舊電腦上安裝，但那部古董總是會在裝到一半的時候突然斷電，沒法用。正好之前在手提電腦上加裝了新硬盤，沒怎麼用，就拿來裝了 Linux。總不可能輕易捨棄隨機附贈的 Windows 和 Office，裝雙盤雙系統就留了後路，也比單盤雙系統安全，安裝時出錯了刪盤重來就好。\n不過現在已經在 Linux 裝好了所有我需要的軟件，Windows 獨佔的也全部都找到了替代品，已經不需要 Windows 了。也嘗試了 Windows 上沒有的 Tiling Window Manage（磁貼式窗口管理器）。聽起來很花時間，但最花時間的不是安裝系統，也不是找替代品，而是重新設置網絡限制。沒有現成的工具真的很麻煩。我總是會忘記，我鎖上的不是保險箱，而是潘多拉的盒子。\n","date":"2024-07-12T07:54:30+08:00","permalink":"https://evthron.github.io/zh/tweet/migrating-to-linux/","title":"遷移到 Linux"},{"content":"我總算按照我想要的樣子，把網站的編排調整一遍了！畫廊能把圖片排成方格、Tweet 能直接展示文章內容、能把自我介紹搬到主頁，把原本的主頁搬到新開的另一頁。主頁就要像目錄一樣，而不是一長串像新聞一樣的時間線。我現在更熟悉 hugo 編排頁面的原理了。當然，HTML 和 CSS 的知識也增長了不少。真的很高興。不過，現在卻不知道接下來該做什麼了。\n現在重新看一次代碼，我完全不知道自己是怎麼做到的。完全不像是我自己寫的啊…… 應該是從原本的代碼裏找到適合的部分，複製黏貼再重組的吧。\n感覺用這個模板很受限制，CSS 雖然好像很有條理，但內容四散，不知道是按着什麼結構組織的。\n認真讀一次就能明白了。\nTailwind CSS 的理念是有道理的，不深思熟慮就胡亂添加一大堆 CSS class 只會讓代碼變得散亂，還不如直接把樣式寫進 HTML。不過總感覺網頁應該要事先設計好才開始動工，所以我有點懷疑。\nhttps://scriptraccoon.dev/blog/tailwind-disadvantages\n","date":"2024-07-01T18:11:52+08:00","permalink":"https://evthron.github.io/zh/tweet/blog-layout-modification/","title":"網站設計"},{"content":"我不喜歡閒聊時大家常常會説的話題。聊天氣吃飯？沒有辦法瞭解對方。聊學習工作？簡直是嚴刑逼供。聊煩惱夢想？又害怕交淺言深。到底什麼話題才能讓閒聊有趣起來？\n對話的基本目的，不就是知道自己不知道的事嗎？所以我想了一個能讓閒聊變得有收穫的挑戰：每次閒聊的時候，都要交換一件對方不知道的事。\n每個人都有自己熟悉的事情，所以不愁沒有交換的材料。可以聊當天的新聞，可以推薦自己最近聽的歌，可以分享自己在維基百科上讀到的冷門知識。不要擔心別人沒有興趣，只要讓別人也説一件他熟悉的事情，你們就扯平了。這就像是玩卡片遊戲的時候互相交換多出來的卡片，雖然自己的卡片和別人的卡組不一定合得起來，但總有機會派上用場的。這樣一點一滴地累積卡片，還能組成一副新的卡組。\n記錄數據\n","date":"2024-06-29T21:43:57+08:00","permalink":"https://evthron.github.io/zh/posts/knowledge-exchange/","title":"交換知識的聊天挑戰 "},{"content":"本來想畫個背景給網站增加點個性，但放上去之後又覺得太雜亂了，所以加了個濾鏡，完全看不出原本的樣子。唉，這就是為什麼現在的網站都不用背景圖片了嗎？純色的背景雖然看上去會比較專業，但是又很無聊。 ","date":"2024-06-26T02:34:57+08:00","image":"https://evthron.github.io/zh/gallery/nightview/nightview_hu11165595516130171112.png","permalink":"https://evthron.github.io/zh/gallery/nightview/","title":"夜景"},{"content":"我只是想做個能黏在網頁旁邊的選單而已，為什麼會這麼難？就算參考了我自己的網站模板，做出來的還是只能黏一半不黏一半。難道 position: sticky 是個很複雜的玩意嗎？\n2024/06/25 03:44 問題解決了…… 關鍵是 max-height 要等於 100vh 減 top-padding 減 bottom-padding。\n","date":"2024-06-25T02:01:20+08:00","permalink":"https://evthron.github.io/zh/tweet/sticky-menu/","title":"黏在旁邊的選單"},{"content":"寫作好像和繪畫不沾邊，但這兩項活動其實是十分相似的。我聽説過有些古代的文人既是文學家，也是畫家，兩項活動對他們來説是不分家的。我自己研究了一下之後，也明白了繪畫和寫作之間相似又相反的奇特關係。\n從表面看，寫文章和畫畫似乎一點相似的地方都沒有：文章是逐字逐句去讀的，但畫是一眼就看得完的；任何人寫作，用的都是同一套漢字，但每個人畫畫，用的顏料都不一樣；好的文章是要複製一千份、一萬份，甚至要翻譯成其他語言，讓世界各地的人讀的，但好的畫作卻是獨一無二的，要是讓其他人重畫一次，就不再是原來的那一副畫了。\n但其實作家和畫家都有一樣的目的，就是把自己觀察到的東西記錄下來。作家寫不出自己沒經歷過的事情，畫家也畫不出自己沒見過的東西。好的作品，一定誠實地記錄下了自己的所見所聞。這裏的誠實，不只是不改變事物原本的面貌，更重要的是不能扭曲腦海裏的真實印象。可以説，並不是因為想要寫作、想要畫畫，才會去觀察身邊的事情，而是因為觀察到了身邊發生的事情，得到了一些印象，然後想要把這些印象記錄下來，才會去寫作和畫畫。\n但是，明明都是在記錄自己觀察到了什麼，為什麼寫作和繪畫這麼不一樣呢？這是因為它們的形式，也就是文字和圖案，是完全相反的兩個極端。文字，是一個個的抽象概念。 所有人都知道什麼是「人」，但每個人心中的「人」都是不一樣的。「人」這個概念，只是一種概括，概括了這個世界上數不清的人。而畫就不一樣了，同一張臉，只要把眼睛的距離拉開一點，縮窄一點，給人的感覺就會完全不一樣。我們是沒有辦法概括一張人臉的，只有實際看到了，才會明白那個人長什麼樣子。兩種方法從不同的起點出發，會遇到的也是不一樣的難題。寫文章的困難，是怎樣組合一個個抽象的概念，才能堆積成生動而獨一無二的印象。相反，畫畫的困難，是怎麼樣堆疊複雜的線條、形狀和顏色，才能引起一種完整的抽象感受。用剛才説的「人」當例子：想描述一個男人很帥很簡單，但要讓人明白到底帥成什麼樣就很難了；想畫出一個女人長什麼樣子很簡單，但要讓人感覺那個女人很漂亮就很難了。\n這兩個問題的解決辦法，就是前面説的誠實。不需要特意去找華麗的文辭，只要用自己會説的話寫出來就可以了；不需要參考大師的技巧，只要相信自己眼睛看到的畫面畫出來就可以了。努力認識、觀察和表達自己和自己身邊的世界，雖然不一定會創作出流傳千古的名作，但一定能創作出對自己有意義的作品。\n","date":"2024-06-21T19:16:06+08:00","permalink":"https://evthron.github.io/zh/posts/writing-and-drawing/","title":"寫作和繪畫 "},{"content":"最近，我和同學在玩血染鐘樓，用的是很方便的網頁版。流程很簡單，主持人建好房間，其他人加入進去。主持人要給玩家發送各種信息，玩家也可以投票。但是玩起來卻有些不方便，很多要獨立發送的訊息發不出去，只能由主持人一個個發訊息，使得遊戲很拖。既然主持可以各自安排玩家的身份，玩家也可以投票回應，為什麼主持人不能在遊戲裏面和玩家互動呢？想必只是開發人員的沒有做出來這個功能而已。\n既然是開源的，我就可以修改。網頁遊戲用的程序應該是 JavaScript，雖然我沒有學過，但是在我自己的網站模板裏是用過的，所以會讀一點。反正又不是我自己重頭做起，只要稍作修改然後上載到我自己的網站不就可以了嗎？\n但是做起來可沒這麼簡單。程序在我的電腦上根本運行不起來，似乎是因為程序是用 Vue 2 寫的，而我安裝的是新版的 Vue 3。 Vue是個比 JavaScript 複雜一點的 JavaScript Framework，光讀源代碼讀不懂。想起之前讀過的一個明明超級簡單的 Flask 程序，楞是運作不起來，就是因為版本太舊的緣故。這麼一來就得學習 npm 的版本管理和程式庫依賴的問題，處理這些對我一點好處都沒有。唉，還是得老實從頭學起。\n","date":"2024-06-19T19:48:42+08:00","permalink":"https://evthron.github.io/zh/tweet/new-to-javascript/","title":"JavaScript 新手"},{"content":"這個世界上到底有多少種旋律？光看一個個音的組合，種類當然無窮無盡。但是真正好聽的組合應該只有一小部分，不可能真的無窮無盡。\n第一個問題是，音樂裏面有幾個音？這個容易回答。隨意選一個震動頻率，把這個頻率加倍，就是高八度的同一個音。在這兩個音之間分割十二份，就有十二個不一樣的音。十二個音太多了，不好編旋律，所以作曲家會挑出當中一部分的音使用，這一部分的音就是音階。\n旋律通常是在某個音階上寫成的。例如 Do Re Mi Fa So La Ti Do形成了大調音階，很多兒歌都是用大調音階寫的。其他音階是在大調音階加上臨時記號之後的變種。例如小調就是把大調音階的第三，第六和第七個音降半音。如果只挑五個音，就會形成五聲音階。如果把這十二個音全部彈出來，就會形成半音階。\n用音階寫旋律雖然方便，但也限制了我們能寫什麽旋律。那麽，如果能發現新的音階，不就能發現新的旋律嗎？\n所謂的音階，可以看作音程的組合。如果把音程限制在半、全、增三種（1, 2, 3），要跨越一個八度的話，到底有多少種可能的音程組合呢？一個八度裏面有十二個音程。如果把所有的音程都彈出來的話，可以寫成十二個一：1111 1111 1111。在大調音階裏面，一步會跳兩個音程，例如從 C 到 D ，有時候也會跳一個音程，例如從 E 到 F。這些音程可以寫成 2212221。用同樣的方式看待小調音階，就會寫成 2122132（這裏指的是和聲小調音階，我後來才發現小調音階有好幾種）。\n我在這個時候發現，之前考試要考的，讓人學得頭昏的組合數學居然派上用場了。這個問題叫做 Combination with replacement 。解決方法叫做 Stars and bars。不過要分別計算每一種的排列的話，就要一個個數出來了。總共有 927 種。\n3333 = 1 33321 = 20 333111 = 20 33 111 111 = 28 33 21 111 = 105 33 22 11 = 90 33 222 = 10 3 111 111 111 = 10 3 21 111 111 = 72 3 22 11 111 = 168 3 222 111 = 140 3 2222 1 = 30 222222 = 1 22222 11 = 21 2222 11 11 = 70 222 11 11 11 = 84 22 11 11 11 11 = 45 2 11 11 11 11 11 = 11 11 11 11 11 11 11 = 1 Total = 927 事情本來到這裏就結束了。但是我又想到，和五聲音階這種連音的數量都不一樣的音階不一樣，大調和小調看似不同，但使用的是的是同一組的音程。音階是循環的，不用加入新的音，也可以形成新的音階，但音程組合並沒有改變。這應該不是簡單的排列組合，而是環形的排列組合。\nAugment: 2222121 Lydian: 2221221 Major: 2212221 Mixolydian: 2212212 Dorian: 2122212 Aeolian: 2122122 Har minor: 2122132 Phygian: 1222122 Phy Domin: 1312122 Locian: 1221222 Altered: 1212222 但是，在環形排列裏面如果有重複的元素，應該怎麼數呢？我這才發現，我從來都沒有碰到過這樣的問題。環形排列在高中就教過了，可以説連小學生都能懂，但為什麼沒有碰到過呢？原來，只要在環形排列裏加入重複的元素，就要用上群論了，一點也不簡單，難怪沒有學過。Burnside\u0026rsquo;s theorem 的原理很複雜，不過算起來倒不難。就是把音階的旋轉對稱性考慮進去，計算每個音階的「軌道」（Orbit）。全部算出來之後，答案是132。也就是說，在一個八度裏分割音程，只有132種可能。\n3333 = 1 33321 = (20 + 0) / 5 = 4 333111 = (20 + 4) / 6 = 4 33 111 111 = 28 + 4 / 8 = 4 33 21 111 = 105 + 0 / 7 = 15 33 22 11 = 90 + 6 / 6 = 16 33 222 = 10 + 0 / 5 = 2 3 111 111 111 = 10 + 0 / 10 = 1 3 21 111 111 = 72 + 0 / 9 = 8 3 22 11 111 = 168 + 0 / 8 = 21 3 222 111 = 140 + 0 / 7 = 20 3 2222 1 = 30 + 0 / 6 = 5 222222 = 1 22222 11 = 21 + 0 / 7 = 3 2222 11 11 = 70 + 10 / 8 = 10 222 11 11 11 = 84 + 6 / 9 = 10 22 11 11 11 11 = 45 + 5 / 10 = 5 2 11 11 11 11 11 = 11 / 11 = 1 11 11 11 11 11 11 = 1 = 1 + 4 + 4 + 4 + 15+16+2+1+8+21+20+5+1+3+10+10+5+1+1 = 132 這樣不是很可惜嗎？明明有132種音階，但是我們只會用其中的兩三種。\n不過，這樣只是從理論角度考慮，音樂要好聽似乎有很多限制，不是隨便挑一些音就能組成音階的。例如至少要保留四度音和五度音，像什麼 33 111 111，寫出來的音樂應該很奇怪，派不上用場。\n説不定，我一開始就搞錯方向了。旋律好像是非常自由的，沒有什麼限制。真正決定音樂好不好聽的，不是和弦嗎？所以我應該去數和弦才對。\n","date":"2024-06-10T12:52:49+08:00","permalink":"https://evthron.github.io/zh/posts/scale/","title":"音階 "},{"content":"我在街上接到傳單的時候，總覺得如果要馬上扔到附近的垃圾筒裏面，那倒不如一開始就不要拿。那廢紙有什麼用呢？拿來折紙也是門手藝。記得小學的數學老師教過怎麼用紙拼出多面體，那比折什麼紙飛機有意思多了。\n從數學的角度看，折紙就和尺規作圖很像。我聽説過折紙連尺規三大不可能問題之一的三等分角都能做到。尺規的基本操作是畫直線和圓，那折紙的基本操作是什麼呢？我拿起手上的傳單試了一下，想必一個是把邊對摺作出垂直平分線，另一個是沿着對角對折作出對角線，都是把東西分成兩半的操作。在尺規作圖上把線三等分不難，那麼折紙有可能把線三等分呢？連三等分都做不到，真的有可能三等分角嗎？\n我在一本折紙書上找到了答案，有種上當受騙的感覺：只要折成四等份，然後把多出來的一份剪掉就可以。就和哥倫布立蛋一樣，只要用力把雞蛋往桌面一敲就可以了。為什麼腦子總是在這種地方轉不過彎來呢？\n不過，的確是有實在的方法等分線段的，不然折紙怎麼能超越尺規作圖呢？但是説來奇怪，在 Youtube 上少有用數學方法分析折紙的影片。三等分角的容易找到，但三分線段的反而找不到，所以我只好自己試了一下。在尺規作圖中，三等分線段的要領在於利用平行定理，把已有的三分線段搬到原有的線上面，重點是作平行線。回到折紙這裏，折一次紙只能作垂直線，但只要明白垂直的垂直就是平行，問題就一舉解決了。這裏分享一點經驗，實際折紙的時候是有誤差的，經常對不準。自制的三分線段和原本線段的夾角要儘量小，作垂直線的時候才輕鬆。\n","date":"2024-06-04T21:14:54+08:00","permalink":"https://evthron.github.io/zh/tweet/origami/","title":"折紙 "},{"content":"只畫黑白素描沒什麼意思。如果要在畫作裏加入顏色，我考慮了好幾種工具，好像是油粉彩最好，既能混合顏色，也能隨時拿出來用。我先測試了油粉彩顏色混合的特性，多少有點經驗之後再開始畫。成品非常不錯吧？雖然感覺油粉彩是小孩的塗鴉工具，但還是要看技術的嘛。 ","date":"2024-05-23T04:02:46+08:00","image":"https://evthron.github.io/zh/gallery/flower-pot/flower-pot_hu5889588066369424592.png","permalink":"https://evthron.github.io/zh/gallery/flower-pot/","title":"油粉彩花瓶 "},{"content":"好玩的遊戲，一定能讓玩家享受自己越玩越好的過程：玩家從規則開始學起，通過一次次的失敗累積經驗，直到成為高手順利通關。這和學習的過程是一樣的，但對學習樂在其中的人不多，因為學習「越玩越好」的過程實在是太長了，還沒有辦法馬上看見自己的成果。而遊戲化，就是用經驗值和等級，把努力的成果變得一目瞭然。\n讓我拿遊戲化網站 Habitica 來當例子。在 Habtica 裏面，你可以向系統加入自己的生活任務，完成這些任務就可以增加經驗值、賺取金幣。但是久而久之，玩耍的感覺就消失了。我發現，這只是一個比較有趣的待辦清單而已。這是因為無論我在遊戲裏面的等級再怎麼高，技能再怎麼厲害，也對現實沒有影響。我在遊戲裏的等級是 88，這些經驗有些是做運動賺的，有些是做作業賺的，有些是自己做菜賺的，具體怎麼樣，我不可能記得清，現在 88 這個數字只能説明我玩這個遊戲玩了很久，不能説明我是運動健將，也不能説明我是消滅作業的高手。遊戲機制也一樣，在 Habitica 裏面，我可以消耗魔力，施展「冷凍冰霜」（Chilling Frost），把任務冷凍起來，這樣一來，就算完成不了任務也不會扣生命值。但現實裏面，我根本沒有這種不做作業也不會被罵的特殊技能。\n遊戲裏面的數值，應該要能應該要能夠轉化成現實裏面的努力。我的方法是，要記錄那些「看得見，增長得快，而且能實際反映能力」的東西。比如學習語言的時候，可以拿詞彙量當經驗值：我懂一百個字，你懂一千個字，那你可以用的字就比我多九倍。如果我努力一點，拿出遊戲刷等級一樣的氣勢，可能只要花四個月的時間就能多學九百個字。不過因為記憶是看不見的，所以一邊學習新詞的時候要一邊記下來，這樣就有了一本能夠反映自己記憶的本子了。我在記錄繪畫經驗的時候，採用了一種更複雜的系統：每畫一副畫，我就會拍一張照，然後我會給這副畫打上標籤，一幅畫可能是畫人的，也可能用了顏色。每一種標籤都對應到一種繪畫的能力，標籤的數量就是那種能力的經驗值，用程序統計好之後做成經驗條，更新到網站上。\n不過，這個系統還是會有很多做不到的事。在學習一項新的技術之前，是沒有辦法預測學習這項技術的時候，到底有什麼東西是「看得見，增長得快，而且能實際反映能力」的。要先練習過一陣子，才能知道到底有什麼東西是適合記錄的，然後回頭修改系統。如果我能把這個系統改得無懈可擊，讓自己樂在其中的話，這個系統可能就能成為一款真正的遊戲。\n","date":"2024-05-09T18:29:26+08:00","permalink":"https://evthron.github.io/zh/skill/introduction/","title":"生活遊戲化 "},{"content":"Arch Wiki 的網絡設置和啟動引導部分寫得不清晰，除此之外不算太難。現在五分鐘就能裝好。\n19/07/2024 現在看來 Arch Wiki 寫得不好的地方就只有安裝指南。無論遇到什麼問題，Arch Wiki 都能解決。\n","date":"2024-04-18T09:26:05+08:00","permalink":"https://evthron.github.io/zh/tweet/arch-linux-installation/","title":" 安裝 Arch Linux"},{"content":"2024/03/30 21:13\n搗鼓了 joppy（用 Python 調用 Joplin 的 API）之後，現在可以直接從 Joplin 生成 Markdown 檔案，無論是發佈還是修改都比以前簡單了。總算能用編程技術做點有用的事了。就算已經寫好了，如果只是放著不看的話是沒有意義的，應該要定期修改檢討才對。\n2024/03/30 23:03\n如果我用普通地利用依賴系統檔案結構的，像 Obsidian 之類的筆記軟件，甚至是 VS Code，能直接打開檔案編輯，而不是用數據庫的 Joplin，不就不用這麼麻煩了嗎？我到底是為了什麼？開源嗎？哈哈哈……\n2024/05/28 12:22\n讀了讀 joppy 的源碼。其實也不是很複雜。只是調用 Joplin 原有的 API 而已。果然讀源碼才是增長知識的最好方法。\n27/12/2024 02:21\n我把 Joplin 的文章全部導出來，變成純文本檔案了。所有的筆記和文章都可以放在同一個文件夾裏，很容易備份，也可以用 vimwiki 修改。發佈流程沒改，還是會先複製一份到 Joplin 裏才發佈。雖然有點麻煩，但能把草稿的和發到網站上的文章分開算是意料之外的的好處。\n","date":"2024-03-30T21:13:23+08:00","permalink":"https://evthron.github.io/zh/tweet/easier-publish/","title":"改進發佈流程"},{"content":"Writing Statistics File count: 56 --- Lv3 ▰▰▰▰▰▰▰▰▰▰▰▰▰▱▱▱▱▱▱▱▱▱▱▱ Frame-of-mind: 10 --- Lv1 ▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▱▱▱▱ Imaginary: 5 --- Lv1 ▰▰▰▰▰▰▰▰▰▰▱▱▱▱▱▱▱▱▱▱▱▱▱▱ Reviews: 11 --- Lv1 ▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▱▱ Stories: 20 --- Lv2 ▰▰▰▰▰▰▰▰▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱ Toolbox: 7 --- Lv1 ▰▰▰▰▰▰▰▰▰▰▰▰▰▰▱▱▱▱▱▱▱▱▱▱ Writing: 3 --- Lv1 ▰▰▰▰▰▰▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱ Input Method English: dvoark Chinese: double pinyin (flypy) Writing Software Joplin FocusWriter VimWiki Obsidian Writing Technique Incremental writing with Obsidian plugin ","date":"2024-03-29T12:53:39+08:00","permalink":"https://evthron.github.io/zh/skill/writer/","title":"class Writer"},{"content":"Skill Engilsh vocab: 28 --- Lv2 ▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▱▱▱▱▱▱▱▱\rChildren books: 0 --- Lv1 ▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱\r","date":"2024-03-28T02:39:05+08:00","permalink":"https://evthron.github.io/zh/skill/foreigner/","title":"class Foreigner"},{"content":"Read Code Script read: 9 Function count: 15 --- Lv2 ▰▰▰▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱ Data-structure: 6 --- Lv1 ▰▰▰▰▰▰▰▰▰▰▰▰▱▱▱▱▱▱▱▱▱▱▱▱ File-system: 2 --- Lv1 ▰▰▰▰▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱ Web: 8 --- Lv1 ▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▱▱▱▱▱▱▱▱ Write Code Python function (script): 54 --- Lv3 ▰▰▰▰▰▰▰▰▰▰▰▰▱▱▱▱▱▱▱▱▱▱▱▱ Python function (module): 29 --- Lv2 ▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▱▱▱▱▱▱▱ Shell script: 17 --- Lv2 ▰▰▰▰▰▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱ Here are my notes on the code I read.\ncode notes\nSoftware Terminal: Konsole Shell: zsh Code Editor: VS Codium Version Control: git Python interpreter: Thonny Site builder: hugo Tagging: filetags Password Management: Keepass Achievements Reinvent the wheel:\nMatrix operations (numpy-like) Scripts:\nAutomate blog publishing Automate blog statistics counting Operating system:\nInstall Arch Linux Set up Chinese input method (fcitx5) Alternative to Dexpot (qtile) Alternative to foobar2000 (Audiotube) Alternative to AutoHotKey (keyd) Alternative to Supermemo (Obsidian Incremental Writing Plugin) Alternative to Cold Turkey Blocker (DNS blocking using dnsmasq) What is Emacs? A highly programmable text editor using lisp. List of shell commands I grasp Web:\nCreate own blog template Tweet Layout Gallery Layout Statistic page Web crawler Software Development:\nWrite an application that randomly shows motivational quotes Write a Joplin plug-in for incremental writing Write a oklch colour picker plug-in for Krita Write a task scheduler that automatically picks daily tasks. Generate oklch intensity charts with different brightness level ","date":"2024-03-25T12:05:21+08:00","permalink":"https://evthron.github.io/zh/skill/programmer/","title":"class Programmer"},{"content":"Skill Collect: 64 --- Lv3 ▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▱▱▱▱▱ Share: 12 --- Lv2 ▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱ ","date":"2024-03-25T12:05:21+08:00","permalink":"https://evthron.github.io/zh/skill/right-sider/","title":"class Right-sider"},{"content":"我已經厭倦 Google 的搜尋結果了（雖然我用的是 Startpage）。今天發現了 marginalia.nu，它能找到一些更小型的網站。順帶一提，Wiby 是另一個專門找小型網站的搜尋引擎，但是因為太小型，全部都很奇怪，所以沒什麼用。\n鏈接：\nhttps://news.ycombinator.com/item?id=28550764\nhttps://ericmurphy.xyz/blog/discoverability/\n2024/04/02 18:50\n我知道的，只要是有趣而且對我無益的事物。我總是會按一個按鈕把它們全部封死，只是看時間和心情有沒有到而已。\n","date":"2024-03-23T01:04:38+08:00","permalink":"https://evthron.github.io/zh/tweet/better-search-engine/","title":"更好的搜尋引擎"},{"content":"Joplin 居然有 Vim mode？那麼我一直以來特意設置 gvim 做外部編輯器豈不是多此一舉？省得調字體和手動保存。\n","date":"2024-03-19T20:20:35+08:00","permalink":"https://evthron.github.io/zh/tweet/joplin-vim-mode/","title":"Joplin Vim Mode"},{"content":"一切的概念只存在於腦海當中，既然有否定自我的、不切實際的幻想，那當然也有肯定自我的、不切實際的幻想。雖然我不喜歡脫離現實，不過用幻想來對抗幻想是理所當然的選擇。\n2024/04/01 00:30 很難……腦海的空想還是打不過眼前所見的現實。尤其是疲勞無法思考的時候，正是這種時候才需要。不對，只是事前的準備功夫不夠而已。無形的概念不能化為實體，有實體的東西才可以化為概念。就好像是抓住看不見的東西一樣。\n","date":"2024-03-19T20:20:35+08:00","permalink":"https://evthron.github.io/zh/tweet/delusions/","title":"幻想"},{"content":"不工作跑去研究工具是沒有好下場的。不過 Super Productivity 和 ActivityWatch 用起來都不錯。要怎樣運用徹底監控電腦使用時間得到的數據，才能把生活變成數值管理遊戲？不過總之先記錄，其他問題以後再想。\n我想破頭之後總算明白了，我手上的時間管理工具在功課上派不上用場。\n待辦清單適合處理繁瑣的工作，但我通常只有四五份功課，根本不需要特意記下來，每一份又要花幾天才能做完，一定要先拆成一個個簡單的步驟，才能放進待辦清單，但沒做過，又怎麼知道任務能不能拆開？空泛地亂拆又沒有用。\n這樣一來，似乎根本不需要用什麼時間管理工具，埋頭苦幹一天做完就行了。但「埋頭苦幹一天」太嚇人了，結果只會拖着，永遠不會開始。而且，一天做完的作業質量肯定不好。和寫文章一樣，要每過幾天重新看一次，不斷修改才可以。\n靠軟件幫忙安排工作，一邊做一邊分拆任務，把拆開的任務分成很多天處理，每次只做一小部分，減輕內心的恐懼，是最好的做法。但是軟件的排程不會理會截止日期，沒法保證一定能在規定的時間內完成。\n説到底，截止日期這個概念本來就是想當然的產物。如果能明確地預測工作時間的話，就直接用那個時間好了。但工作時間當然是無法預測的，只能設一個過分充裕的期限，讓人變得拖拖拉拉。\n我理想的時間管理工具該有的要素：\n任務隊列，按照緩急輕重和完成的收穫自動安排每日的任務，出現什麼就做什麼，沒得選。 每項任務都是一個文本檔案，因為無論什麼任務都需要寫工作筆記。 遇見複雜的任務可以拆開，形成樹狀分支 任務清單，能觀察自己每個項目的進度，彌補任務隊列把任務拆得亂七八糟，見樹不見林的不足 有了會很好：\n能自動打開任務需要的檔案，減少切換的麻煩 遊戲化，在完成任務的時候會「叮」的一下加分。 能製作記憶卡，混入任務隊列 時間追蹤，提醒自己不要在同一個任務上花太多時間。 雖然把一大堆工具合併起來用就能滿足上面的所有要求，但如果還是要奢望有一個萬能的合體機器人的話，就只會走上 emacs 的不歸路。怎麼辦，好像很吸引人……\n又不小心研究了一會 emacs，因為 orgdown 的語法好像比 markdown 好。練習快捷鍵除了輸入的時候比較爽快沒有什麼意義。我很滿意 vim。過早的優化是萬惡之源。有些人連盲打都不會呢，照樣能寫出好的程序。\n","date":"2024-03-19T20:20:35+08:00","permalink":"https://evthron.github.io/zh/tweet/productivity-tools/","title":"時間管理工具"},{"content":"亂搜東西算是我最後一個在網上浪費時間的方法了。要怎麼限制搜索次數？難不成還要自己寫個插件嗎？最後的做法是這樣的：瀏覽器打開的時候會有十個搜尋分頁，等於一天有十次搜尋機會。還要把網址欄的搜尋功能取消掉，和讓瀏覽器記住關閉前的分頁。比用計數器自己計算搜尋次數好多了。\n2024/04/07 03:36\n可惜我沒有貫徹這種規則的工具。本來是個好主意的。\n","date":"2024-03-19T20:20:35+08:00","permalink":"https://evthron.github.io/zh/tweet/search-count/","title":"搜尋次數"},{"content":"Overall Total_count Lv8 82 remain Skills lines Lv2 18 remain colour Lv3 30 remain perspective Lv1 5 remain figures Lv4 14 remain hands Lv1 1 remain heads Lv3 21 remain Sketchbook Book used 10 file_count Lv7 1 remain sight Lv5 10 remain copies Lv5 56 remain doodles Lv1 7 remain home Lv6 57 remain outdoors Lv5 42 remain completed Lv2 14 remain Digital file_count Lv2 21 remain lines Lv1 10 remain colour Lv1 5 remain scanned Lv1 11 remain photo Lv1 7 remain sight Lv1 10 remain completed Lv1 8 remain Tools Digital:\nKrita One by Wacom Medium CTL-672 Physical:\nLyra Rembrandt Art Design pencils Sakura Cray-Pas Oil Pastels uni Nano Dia 0.5, 2B \u0026amp; 4B Leads Zebra DelGuard 0.5 Mechanical pencil MONO Plastic Eraser NDK Cutter S-800 Colleen Colour Pencil Cardboard viewfinder Cardboard colour wheel Achievements Drawing at:\nHome Park Mall Minibus Restaurant Beach Hospital Street Lecture Room Sports Centre Railway Library Art Museum Finish a drawing using:\nPencil Fineliner Willow charcoal Acrylic Coloured pencil Oil Pastel Ballpoint pen Rubber on charcoal Sand and stick Window and water vapour Printout images Subject matter:\nSelf-Portrait Portrait for others Avatar Icon Collection Books: 14 --- Lv2 ▰▰▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱▱ Andrew Loomis - Drawing the Head and Hands Andrew Loomis - Figure drawing for all it\u0026rsquo;s worth\nBoth are the classic books that often gets recommends until this day. They presents more examples than explanation so I still need to copy a lot more drawings of to get the most out of them. Betty Edwards - The new drawing on the right side of the brain\nA very important book for beginners. It explains the reason why people draw badly is that they only draw symbols instead of what they actually see. Anyone could draw well once they know the knack. Betty Edwards - Color : A Course in Mastering the Art of Mixing Colors\nIntroduces the important concepts about colours: colour wheels, components of colour (hue, saturation and value), and how to actually mix them. Charles Williams - Basic drawing : how to draw what you see\nDrawing doesn\u0026rsquo;t have to be masterpieces, it can be a dirty doodle drawn on boring lectures. In fact, the book said you don\u0026rsquo;t have to draw what you see. Most example shown are rough sketches, which makes it beginner-friendly. Donna Krizek - Drawing and sketching secrets : 200 tips and techniques for drawing the easy way\nIntroduces a lot of advanced techniques around many traditional media. It\u0026rsquo;s examples are all masterpieces so it\u0026rsquo;s not very useful to me yet. Gilles Ronin - Le dessin en perspective a main levee\nIntroduces the mathematical knowledge behind the construction of accurate shapes, shadows and perspective. It\u0026rsquo;s very interesting to learn the principles but not very useful to me for now since I don\u0026rsquo;t need this kind of precision. James Hobbs - Sketch Your World\nGiving me the idea of outdoor sketching, which is much more interesting than drawing indoors. To me, drawing is the best way to spend outdoor time. Mark Kistler - You can draw in 30 days : the fun, easy way to learn to draw in one month or less\nA true beginner\u0026rsquo;s book. It\u0026rsquo;s first lesson is to teach you how to draw a ball, then a cube, then a cylinder, then all the basic techniques in drawing. To me, the most brilliant technique introduced is smudging. Although any art teacher will tell you this is bad, this is much more beginner-friendly than cross-hatching, while the effect created is still stunning. Mark Kistler - You can draw it in just 30 minutes : see it and sketch it in a half-hour or less\nThe next book in the series, nothing special but still quite fun. Rudy de Reyna - How to draw what you see\nEvery object is a combination of spheres, cubes, cylinders and cones, really? R. O. Dunlop, R.A - Painting for pleasure\nIt recommends pastels as a good outdoor medium, although I later found out that it meant the powdery ones. Powdery pastels are more expensive and create a powdery mess. So I\u0026rsquo;m satisfied with the oily ones. It is another book that encourages beginners to do outdoor painting. Sam Piyasena, Beverly Philp - Just draw it!\nIt gives out lot of interesting ideas on creative art making, not bounded by traditional media. 趙巍岩, 陽佳, 楊萌 - 物我之間 : 寫生的一種方法 (Between object and subject : painting as a way to perceive and express)\nIt thoroughly discussed how should we practise drawing to learn our true styles. Artistic drawings are not likely to be eye candies. We draw not only what we see but beyond what we see. ","date":"2024-03-10T06:10:52+08:00","permalink":"https://evthron.github.io/zh/skill/painter/","title":"class Painter"},{"content":"不把事情徹底完成就無法推進，這並不是好的做法。先完成初版再不斷更新才是有效的做法。但是，要如何知道自己完成了？除非能夠預知未來，否則就沒有辦法能估計自己的項目推進到哪一部分了。不對，就算能夠預知未來，也不知道要怎麼才能把自己的工作量變成數值反映在進度條上。\n","date":"2024-02-26T01:49:21+08:00","permalink":"https://evthron.github.io/zh/tweet/progress/","title":"進度"},{"content":"顏色是由色相、明度、飽和度決定的，排除明度和飽和度的干擾，才能培養對顏色關係的正確感覺。我用 OKLCH 顏色選擇器 做了個符合色覺認知的色環。色環上的顏色有着相同的明度（Brightness）和飽和度（Chroma），色相（Hue）的間隔也是均勻的。\n顏色數據：\nChroma = 0.12。不同的色相有不同的亮度範圍，所以會出現色相斷層。不想要色相斷層的話，0.12 是在 sRGB 空間中能達到的最高飽和度。 一決定 Chroma，就決定了亮度範圍，我選了 Brightness = 75。 2024/05/25\n這是一幅沒有明暗，沒有色彩對比，只有色相變化的畫，看起來非常不舒服。 改用飽和度最高的預設顏色重畫一次。雖然像是用小畫家亂畫的，但看上去居然舒服了不少。這是因為在調色盤裏的基礎顏色，本來就有不一樣的亮度和色彩對比。不過很難從這些各異的顏色出發，調出自己想要的顏色。 一般軟件的 HSV 顏色選擇器，只是把最鮮豔的顏色當成基礎色，然後把明度和飽和度的數值定為 100，這是不行的。因為不同的顏色，明度的上下限是不一樣的。用 RGB 像素説明最簡單：紅加綠得黃，如果把最亮的紅光和最亮的綠光混合起來，出來的黃光是不是比單獨的紅光或綠光亮？同樣原理，青色和洋紅色也能比單色光更亮。所以顏色選擇器的數值只是相對數值，改變了色相，就不能比較飽和度和亮度。\n實際的情況更加複雜，不只是顯示設備的問題，還涉及人眼的運作。不過，oklch 已經把種種因素考慮在內，所以能用絕對數值描述顏色。這也是個感知均勻的色彩空間，不會在改變明度的時候出現色彩偏移。\n色彩空間自然是連續的，一般的 RGB 顯示屏可以顯示一千六百萬種顏色，但是這對畫畫一點用都沒有。要讓顏色變得容易理解，就要套用傳統美術的色環概念。\n受限於過去顏料的限制，傳統藝術的顏色系統以 RYB 為基礎，這樣做出的色環是有偏差的。紫紅色代替了洋紅色，青色乾脆就不存在，使得色彩之間的互補關係不準確。雖然現在能買到洋紅色的顏料，但它照到光就會褪色，不適合作畫。沒有人會希望自己的畫展出一年後就變得像舊海報一樣藍，所以這種新顏料沒有普及開來。\n電腦自然不用顧慮這種物理問題，所以糾正大家色彩觀念的時候到了。現代的色環即使考慮了色相，也沒有考慮明暗和飽和度，所以我自己做了一個。我還做了不同明度的顏色飽和度圖，把明度分成 6 個等級，把飽和度分成 10 個等級。 要是能在繪畫軟件裏直接使用這個取色器就很方便了，可惜現在還沒有。Krita 的開發人員很重視色彩空間，所以我還是很有信心的。\n","date":"2024-01-29T05:05:42+08:00","image":"https://evthron.github.io/zh/gallery/accurate-colour-wheel/accurate-colour-wheel_hu17557053021048497530.png","permalink":"https://evthron.github.io/zh/gallery/accurate-colour-wheel/","title":"準確的色環"},{"content":"以前，互聯網對我來説，是個充滿知識、幻想和樂趣的遊樂場。但現在，我卻在想盡辦法把互聯網從我的生活裏趕出去。原因很簡單，不就是因為互聯網是個充滿無用的知識、虛妄的幻想和過剩的樂趣的遊樂場嗎？在網上得到的樂趣，讓自己放棄了多少次反抗外界壓力的機會？又讓自己擱置了多少個改變生活的願望？\n不過，如果你和我一樣，真的有放棄互聯網的決心，一定會一次又一次地失敗。原因無非有兩個。\n第一，依賴決心。決心這玩意只在自己有決心的時候有用，沒有決心的時候就連廢紙都不如了，怎麼會有這麼不方便的東西？對付互聯網這麼吸引人的玩意，怎麼能靠自己一戳即破的決心？對抗誘惑，外界的束縛是最有用的。但是外界的束縛又讓人討厭，讓人有反抗的心思，而天底下沒有毫無破綻的束縛，一定會有漏洞，只要束縛一破，陋習就會變本加厲。所以，要點在於讓自己設下別人執行規則。\n第二，限制過緊。要是像上面説的一樣，為自己設下牢不可破的障礙，像是把手機鎖在箱裏了，把電腦砸了，到了真的有需要用的時候，一定會氣急敗壞，悔不當初，從此絕口不提斷網的事情了。或許在別的世界裏，要得到好處就要抵得住誘惑，但是在電腦的世界裏沒有這種常識。把不需要的部分像挑魚刺一樣全部剔除，只留下自己需要的部分，才能算是個聰明的用家。\n在經歷了數不清的後悔、數不清的悔改和數不清的重蹈覆轍之後，我終於摸索出了一套好用的工具來限制自己上網。雖然還不是很完美，但要是能全部用上，你就勝過大部分還矇在鼓裏的人了。\n限制上網的方法從嚴格到寬鬆可以分為三種：禁止，預防，減少興致。禁止是封鎖自己上網的途徑，預防是防止自己發現新的資訊。減少興致是為自己上網增加一點麻煩。按你自己的需要配合着用吧。\n手機 手機是最危險的。絕對沒有人需要隨時隨地都可以上網，想看什麼就看什麼的手機。對付手機，我只有禁止策略，沒有預防和減少興致的策略。\nHelpMeFocus (Android) 不錯的 App 阻擋器。它可以把自己也阻擋掉，這是很重要的功能。\nUniversal Android Debloater (Android) 在 Android 上，Google Chrome，Youtube 和 Play Store 是系統預裝軟件，一般是刪不掉的。要動用 Universal Android Debloater (github) 這個大殺器才能除掉。\n用不着 Play Store，也可以更新軟件。有些軟件會在官網上直接放出安裝包。要是沒有的話，多數也能在 APKMirror 一類的鏡像網站找到。實在沒有辦法的話，就暫時重新啓用 Play Store 吧。\n螢幕使用時間 (iOS) iOS 可不像 Android 那麼自由可以隨意禁用軟件，不過 iOS 的數位健康功能做得很嚴格，只能用密碼解鎖。\n電腦 電腦能用的工具比較靈活，可以在瀏覽器裏安裝擴充套件，不像手機一樣，只能整個 App 屏蔽掉。\n阻擋：Leechblock NG 這是必備的網站阻擋器。你可以試試各種各樣的封鎖策略，設置使用倒計時，或者按時間段封鎖，都是可以的。不過，我的經驗告訴我應該要做得絕一點，不需要上的網站就要完全封鎖。\n如果有些網站讓你下不去手封鎖，就要仔細研究網站的域名，你可能只需要其中一部分讓你分心的頁面，例如我只需要看知乎專欄 zhuanlan.zhihu.com，而不需要知乎的問答部分 zhihu.com。\n不過 Leechblock 是瀏覽器插件，只能阻止一個瀏覽器，誰也攔不住你安裝另一個。你能做的就只有把世界上所有瀏覽器的下載頁面封鎖掉。\n阻擋：Cold Turkey Blocker 這個軟件比上面的更進一步，要求瀏覽器必須安裝它的封鎖插件才能啓動。封鎖的程度也很徹底，只要設了時間限制，除了捐錢沒有任何解除封鎖的方法，就算把軟件刪掉也沒用。一般人不可能知道它用了什麼原理，所以這是最強的封鎖軟件。沒有比絕對可靠的規則更讓人感到安心的東西了。\n預防：uBlacklist 要是搜尋的時候總是看到那些自己已經擋掉的網站，一定會有解除封鎖的衝動，所以要讓阻擋了的網站從搜尋結果中消失，不讓自己意識到自己阻擋了內容。\n新網站往往是最危險的。uBlackList 能在搜尋結果裏除掉自己不想看見的網站。\n減少興致：uBlock Origin 你説不定知道這是個攔截廣告的軟件，但重點不是這個。這是個萬能攔截器，只要網站上有讓你分心的東西，像是百科全書底部能跳到其他相關頁面的連接，或是搜尋頁面上翻到下一頁的箭頭，你就可以用元素選擇器把它們除掉。\nYoutube 值得為了 Youtube 專門開一段。Youtube 讓人又愛又恨的原因，是上面有數不清的實用學習視頻，而同樣也有數不清的無用娛樂影片。如果是要應付考試的話，看視頻可能比讀教科書還好，所以很難割捨。這自然也有應對方法。\n阻擋：BlockTube 把自己不喜歡的頻道屏蔽掉。特別是那些上百萬次播放量的娛樂頻道。 還可以按時間和語言篩選。重要的教學影片都是英文的，不會太長也不會太短。\n預防：Unhook 讓主頁和推薦影片欄都變得一片空白，然後好好管理自己訂閲的頻道。想看其他內容就只能自己搜尋了。\n減少興致：yt-dlp 這是一套組合招式。在看 Youtube 之前影片前先下載好，讓自己考慮一下才決定要不要看。至少不會輕易點進一個多小時的遊戲直播了。\n先用 Leechblock 禁止播放影片的 watch 類頁面，然後在 Ublock Origin 的自定義靜態規則裏加入 youtube.com##ytd-continuation-item-renderer，停用無限加載，最後在搜尋頁面複製好鏈接，扔進 yt-dlp 裏下載。\n用 RSS 閱讀器集中內容 無論是 Youtube 還是新聞網站，都能用 RSS 閲讀器訂閲。這樣就能集中觀看自己訂閱的所有內容，不用在其他網站流連。電腦可以用 Feedbro，手機可以用 Feeder。\nLinux 説這個之前先抱怨一句，研究網絡研究得越深入，就能找到越多破解網絡封鎖的辦法。什麼都不知道反而輕鬆，這就是知識的詛咒。不過既然已經開始研究了，就只能研究到底了。\nLinux 和 Windows 其實並沒有什麼區別，除了 Cold Turkey Blocker 之外全部都能用。可能 Cold Turkey Blocker 的作者也知道，在 Linux 上不用瀏覽器也能上網，破解網絡封鎖的辦法也多的是，所以，封鎖網絡只能中斷網絡連接本身，這需要修改電腦的網絡配置才能實現。\n網址要先轉換成 IP 地址才能上網，這個過程叫作「域名解析」。只要手動干擾域名解析，就能中斷網絡。\ndnsmasq 首先要安裝一個域名解析工具，dnsmasq 能配合 Linux 上常用的網絡配置工具 NetworkManager 使用，是不錯的選擇。 在 etc/NetworkManager/dnsmasq.d/block.conf 裏，把自己要封鎖的網站一行行加進去。\naddress=/example.com/ address=/example1.com/ ... 現在上 example.com 的時候就解析不了域名。\netc 文件夾裏的文件是系統設定，需要 root 權限才能修改。先限制好自己的 sudo 權限讓自己沒有辦法修改文件，然後把 root 密碼藏起來。這樣就沒有辦法修改 dnsmasq 的設定了。不過我還沒有這樣做。只要解除封鎖的過程足夠複雜，我就不會自找麻煩了。要知道，拆掉自己建好的東西是多麼痛苦啊。\n網上也有一些別人辛苦整理好的封鎖列表，像是 dns-blocklists (github)。你也可以拿來用。\nDelayed-admin dnsmasq 只是在域名層面的一道基礎防禦，沒有辦法像 Leechblock 一樣靈活地控制開放時間和針對 URL 禁止網站。我只要下載另一個瀏覽器，就能繞開這些插件的限制，所以我還需要防止自己安裝瀏覽器。\n在 Linux 系統裏，只要放棄 root 權限就安裝不了軟件，不過我既是用家，也是系統管理員，需要升級系統、更改系統設定，以後也需要安裝新的軟件，所以我不能這樣做。怎樣防止自己監守自盜的問題一直讓我很頭痛。用到 root 權限的頻率很高，所以我像不能把密碼放在家裏的硬盤裏，等到需要的時候才拿出來。\ndelayed-admin (github) 用很簡單的想法解決了我的煩惱：讓自己先等待一段時間，才能執行操作，就能抵住一時的鬼迷心竅，不會剛看完電影，急着上網看影評，發現影評網站被自己擋掉了就下載另一個瀏覽器，然後沉溺在沒有插件限制的網絡裏了。\n詳細的原理是這樣的：在 Linux 裏，可以指定用户屬於什麼羣組，然後根據不同的羣組，分發不同的權限。具體會用到 sudo 這個程序分發權限。前面説到用户需要 root 權限來執行和修改系統設定有關的操作，但如果一直持有 root 權限的話，會有安全問題，所以一般都只會在需要的時候，用 sudo 指令臨時賦予自己 root 權限。在 sudoers 設定檔裏，可以細緻地設定什麼人，什麼羣組，可以在什麼樣的指令上使用 sudo。\n而 delayed-admin 這個程序會新增一個 delayed-admin 羣組，這個羣組沒有常規的 root 權限，羣組裏的用户只能用 delayed 指令執行需要 root 權限的操作，等待一段時間後才會執行。做法是在 sudoers 文件裏加上一行：\n%delayed-admin ALL = /usr/local/bin/delayed 這個 delayed 程序也很簡單，主體邏輯只有三行。\nCMD=${@} sleep \u0026#34;$delay\u0026#34; $CMD 雖然很簡單，不過這就是我一直想要的工具。\ndelayed-admin 還有另一個模式，是讓自己在指定時間內離開 Wheel 羣組（ 一般會在 sudoers 裏設定，讓 Wheel 羣組的用户獲得和 root 一樣的權限）。雖然我用不上，但因為我在安裝這個的時候遇到了點麻煩，所以還是在這裏記錄一下使用 setup.sh 安裝之後要做的事。\n安裝 at，排程工具 手動建立 /etc/sudoers.d/delayed-admin，加入上面的 sudoers 設定 不要在 sudoers 裏給自己 root 權限，而是把自己加進 wheel group，再給 wheel group root 權限。 其他問題（su 和 kdesu） 要防止自己用 su 獲得 root 權限，需要在/etc/pam.d/su and /etc/pam.d/su-l 加上一句：\nhttps://wiki.archlinux.org/title/Su#su_and_wheel\nauth required pam_wheel.so use_uid 在 KDE 裏，如果用户需要 root 權限，會使用 kdesu 這個程序，讓用户輸入 root 密碼，這樣用户就可以用 KDE 的 Dolpin 文件瀏覽器進入系統管理員模式，繞過上面的限制。要防止這種情況，需要修改 Polkit （PolicyKit）的設定。\n要先讓 kdesu 像 sudo 一樣運作，在 ~/.config/kdesurc 加入: https://wiki.archlinux.org/title/Sudo#kdesu\n[super-user-command] super-user-command=sudo 接着是修改 polkit，設定是根據 Bypass KDEsu Authentication Dialog (archlinux bbs) 和 How do I \u0026ldquo;graphical-sudo\u0026rdquo; under KDE (not \u0026ldquo;su\u0026rdquo;)? (gentoo forum) 改的。\n在 /etc/polkit-1/rules.d/10-admin.rules 裏：\n// 讓 Wheel 羣組的用户輸入用户密碼，而不是 root 密碼。這部分和上面無關，只是不需要使用 root 密碼的話，就算換一個複雜一點的密碼，甚至直接消除密碼，無法登入 root 也沒問題。 polkit.addAdminRule(function(action, subject) { return [\u0026#34;unix-group:wheel\u0026#34;]; }); // 如果用户想在 Dolphin 裏面提升權限，直接否決 polkit.addRule(function(action, subject) { if (!subject.isInGroup(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; action.id == \u0026#34;org.kde.kio.admin.commands\u0026#34;) { return polkit.Result.NO; } }); ","date":"2024-01-29T04:13:29+08:00","permalink":"https://evthron.github.io/zh/toolbox/say-goodbye-to-internet/","title":"如何告別互聯網"},{"content":"從一點到三點，過了幾個小時？2021年出生的孩子，到了2023年幾歲？計算這些可能很簡單，但時刻、小時、年份、年齡背後的概念，量數1和序數的關係，並不是一目了然的。\n量數遠比序數有用。量數是表示數量的數，可以進行加減乘除等數學運算，這些運算對應着現實中物件的合併和分割；而序數只是表示物件先後次序的標籤，沒有數學運算可言。比如在時鐘上，兩點在一點的後面，三點在兩點的後面，但是不能把「一點」和「兩點」加起來得到「三點」，這是沒有意義的。\n要利用序數，就要先轉換成有用的量數。對於不同的問題，我們關心的量數是不一樣的，所以轉換方法也不一樣。\n在數物件的時候，我們關心的量數是「物件的量數」，這剛好和「最後一個物件的序數」是相等的。比如要知道桌子上有幾個蘋果，就要「第一個，第二個，第三個」這樣數出來。如果數到了第三個蘋果，數過的蘋果總數就是三個。\n但是有時候，我們想知道的量數，是序數之間的「距離」，和序數本身無關。比如說時鐘使用的序數是「點」，但我們並不關心時間點的數量，而是經過了幾個小時，也就是時間點之間的「距離」。從一點到三點過了三個時間點，但只過了兩小時。數法是一點走到兩點一小時，兩點走到三點兩小時。同樣，計算年齡使用的序數是「年份」，但我們也不關心經過了幾個年份，只關心過了多少年。年也是一種距離。2021 到 2023 年總共過了三個年份，但只長了兩歲。\n序數相減得出距離。只要計算 3 - 1 = 2，2023 - 2021 = 2，就知道度過了兩小時，長了兩歲。換個方向，把序數加減一個距離，就可以得到另一個序數。比如從一點開始過了兩小時，就到了 1 + 2 = 3 點。\n這些雖然是基礎得不能再基礎的算數題，但要注意，理論上序數可以從任何數字開始數，方向也不是固定的，所以轉換方法也不一樣。這是在生活中不會出現的問題，因為我們總是從 1 開始順着數；但是在麻煩的程式語言領域是從 0 開始數的，所以不把這些概念弄清楚的話，會有很多麻煩。\n集合論一般稱為基數，我只是挑了個我喜歡的詞。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-01-20T22:43:24+08:00","image":"https://evthron.github.io/zh/posts/cardinal-ordinal/apple-clock_hu14482892738896188828.jpg","permalink":"https://evthron.github.io/zh/posts/cardinal-ordinal/","title":"量數和序數"},{"content":"本來只是想試試新製作的色板，但沒想到竟然可以畫得這麽好。第一次買這種盒子形狀的新時代扭蛋就被概率背叛了。雖然不想要這種古怪玩意當擺設，不過可能正正是不想要的東西畫起來才有趣。\n","date":"2024-01-11T06:05:11+08:00","image":"https://evthron.github.io/zh/gallery/the-lizard/the-lizard_hu5513668176132256873.png","permalink":"https://evthron.github.io/zh/gallery/the-lizard/","title":"蜥蜴人"},{"content":"互聯網能促進交流，這似乎是理所當然的。感覺只要有一部手機，無論是身在國外的舊同學，家鄉的親人，還是只有一面之緣的人，發一個訊息就聯繫得上。但是為什麽我們還是覺得孤獨？就算手機裏有一百個聯絡人，關鍵時刻能聊上天的人還是一個都沒有。\n其實即時通訊並不是現實聊天的補充，而是一種另類的信件交流。它的設計和一百八十年前 1 的郵遞送信一樣，仍然是由三個步驟組成：寫信寄出，等待回信，閱讀回信。因此，找不到適合的交流對象也不足為奇。\n寫什麽？ 寫信的第一個問題是，寫什麽？這似乎是很自然的第一步，不過在現實生活中，這個問題並不重要，因為話題可以從身邊的環境取材，並沒有特別的意義。甚至可以說，生活中大部分的交流，都是由沒什麽意義的內容組成的。身處在相同的空間，是交流的最大動力。有了這個動機，具體說些什麽其實是不重要的。\n但是在網絡上，交流雙方並沒有共享相同的環境，所以並不允許這麽方便隨意的交流。沒有具體的話題、具體的目的，交流就不能開始。正如人不會為了寫一句「天氣不錯」，就跑到郵局寄信一樣。\n結果就是，我們一開始的目的可能只是想找個人說說話，卻要被具體的話題束縛。\n收得到回覆嗎？ 假設我們已經想好了話題，信也寄出去了。接下來就只能等待回信。但是我們寄的是一瞬間就能送達的信，為什麽還要等待？只有兩種原因。要麽是收了沒拆，要麽是看了沒回。在收到回信前，無法確定是哪一種情況。最壞的情況是，對方馬上就讀了信，但是不想回覆，也就是交流在信寄出去的一瞬間就失敗了，也永遠不會收到回覆。如果害怕這種最壞的情況，就不會去寄信。\n讀了回覆會滿意嗎？ 如果收到回覆了，交流是不是就成功了呢？還不行，因為文字難以傳遞真情實意，所以回覆很難令人滿意。但是，以前的人都使用信件傳遞感情和想法，為什麽到了即時通訊，文字就行不通了？問題在於，大家寫的不是信，而是對話。文字對話的兩個特點，時間差和篇幅短，正正是真情實意的反面。\n首先是缺乏真實感。交流的時間差給了人編造內容的機會。往極端了講，甚至可以是為了操弄人的行動和情緒而完全虛構出來的。只要有了這個可能，大家心裏就會想，「你寫的這句話裏，到底有多少是真的，多少是假的？」所以無法完全相信對方說的話。\n而且短句子包含的感情太少。不但丟失了聲音、表情和動作的資訊，還得不到文字用長篇幅表達複雜意思的能力。順帶一提，表情符號和表情包傳達感情的效果並不好。發一個 emoji😀的效果，還不一定比得上寫一句「我很高興地說」。因為表情符號和表情包的意思不固定，濫用還會讓人讀出弦外之音。\n所以，即時通訊不僅難以開啟話題，不知道何時收到回覆，回覆也難以令人滿意。它的限制太多，使得大家不太願意用它交流。\n模仿真實的對話 不過，也不是沒有拯救即時通訊的辦法，那就是讓文字對話產生和直接對話一樣的效果。我想這也是覺得即時通訊沒有任何問題的人，不自覺間採用的做法。\n雖然即時通訊是一封信，我們卻不應該精心編寫訊息；增加篇幅對表達有幫助，但會拖長回覆的時間，引起猜疑。相反，我們應該用說話的速度打字，順帶還能增加篇幅。其實就是想到什麽就寫什麽，要是說錯了話，馬上修正就好。\n還有在對話結束的時候要明確地道別。很多時候都不知道怎麽地，話題就聊不下去斷了，又有時候明明應該已經結束了的話題，過了一天又不知道怎麽地有了回覆。就像在現實中揮手道別的時候，聚會就結束了一樣，訊息聊天也應該有一個明確的結束時機。\n往全世界分享 往另一個方面想，互聯網能夠讓我們對全世界廣播自己的想法，那為什麽還要侷限在單對單的信件交流呢？\n我們期望的「交流」，有時候只是向其他人扔出一個又一個的想法而已。為何不把這些想法扔向全世界？這種做法叫「分享」。分享沒有特定的交流對象，這個特性能消除上面所說的、即時通訊有的所有缺點。\n第一，話題只需要自己感興趣就可以。 第二，不期待回應，讓人讀到自己的訊息就是全部目的，所以絕對不會失敗。而且只要帖子還在網上，就不斷會有新的人讀到。 第三，沒有說謊的理由，也有充足的篇幅表達自己的想法，所以給人可信的感覺。\n其實大家每天在社交網站發帖，就已經在分享了。但是社交網站有各種各樣的問題，比如光讀不寫、浪費時間、龍蛇混雜等等。微信朋友圈的形式也不錯，只會看到朋友的內容，但是不能讓所有人看到自己寫的東西還是有一種小家子氣的感覺。所以要在網絡上立足分享，還是需要一個自己的網站。雖然我能建好，但一般的人應該不懂。所以至少要把自己創造的內容，放在不需要登入也能讓所有人看到的地方。\n世界上第一張郵票「黑便士」是在 1840 年發行的，沒有郵票的話，一般民眾應該很難寄信吧。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-12-29T16:36:02+08:00","permalink":"https://evthron.github.io/zh/posts/instant-messaging/","title":"即時通訊的障礙"},{"content":"真的好冷啊。上星期還是熱得和夏天一樣，還以為能過個暖和的冬天。\n","date":"2023-12-22T18:20:01+08:00","permalink":"https://evthron.github.io/zh/tweet/winter/","title":"冷天"},{"content":"現在的鍵盤佈局完全沒有考慮過人體工學：\n沒好好利用有力的拇指，反而浪費兩隻手指按一個空格鍵。難得兩個 Alt 鍵很容易用拇指按到，卻不常用。 常用的 Enter 和 Backspace 要用小指去按，還離得很遠。 沒用的 CapsLock 放在了小指能輕鬆按到的位置。如果你習慣用 CapsLock 打大寫字母的話，我建議你改用 Sticky Keys。 還有一個少數人才能遇到的問題：文字編輯器 Vim 很常用到 Esc 鍵，但這個鍵居然在鍵盤的左上角。 至少要改成這樣才算理想的鍵位：\nCapslock -\u0026gt; Backspace Left Alt -\u0026gt; Esc Right Alt -\u0026gt; Enter 鍵盤上還有不少多餘的鍵：\n上面一排 F1 到 F12 沒什麼用。有用的預設功能只有 F2 （重新命名）和 F3（搜尋）；勉強稱得上有用的有 F4 (Alt+F4 強制關閉窗口)、F11（放大窗口到全屏幕）；只有網頁開發人員有用的有 F12（打開網頁源代碼）。這些功能真的值得專門佔一個寶貴的鍵嗎？ Insert、Pause、ScrollLock，NumLock，這些鍵已經沒有意義了。Home、End、PgUp、PgDn 也不算常用。 另一方面，快捷鍵的設計也是在折磨手指。軟件的快捷鍵一大堆，常用的就那麼幾個，還可能是 Ctrl + Shift + Alt + P 之類的奇怪組合。用鍵盤上多餘的鍵取代組合鍵就再適合不過了。我們應該好好感謝這些殘留下來的歷史按鍵，多一個鍵，就能多設定一個功能。\nAutoHotKey 是 Windows 的改鍵工具。很簡單就能實現這些要求。我把鍵盤設定成這樣：\n打字 打字舒服是最重要的。\nCapslock -\u0026gt; Backspace Left Alt -\u0026gt; Esc Right Alt -\u0026gt; Enter 這麼一來就沒有 Alt 可以用了，可以把 Alt 搬到 Compose 、Right Ctrl、Backspace、或者某個 Fn 鍵上，偶爾會用得上。 Enter -\u0026gt; Win + Space（切換中英文輸入法） 瀏覽器操作 真不知道這些快捷鍵是誰設計的。説起來也可以安裝插件，用 Vim 鍵位操作頁面，但我覺得還是方向鍵比較方便。\nF6 -\u0026gt; Shift + Ctrl + T （打開上一個關閉的分頁） Delete -\u0026gt; Ctrl + W （關閉分頁） PgUp -\u0026gt; Ctrl + Shift + Tab （往前一個分頁） PgDn -\u0026gt; Ctrl + Tab (往後一個分頁) Insert -\u0026gt; Ctrl + T （新增分頁） 啓動軟件 F1: 番茄鐘 F4: 字典（Saladict） F7: 命令窗口（Terminal） F8: 筆記軟件（Vim） 我的鼠標上有兩個額外的鍵用作複製和貼上。如果鼠標上沒有額外按鍵的話，我還會把它們放在兩個 Fn 鍵上。\nAutoHotKey 有一些缺點，你用着用着就知道了。ahk 腳本的格式不太容易學；登入界面和資源管理器是用不了快捷鍵的，因為這些都需要需要系統管理員權限。不過功能很豐富，可以滿足一切自動操作的需求。\nKeyd 不知道算 Linux 上沒有 Autohotkey 算不算可惜。不過我也不需要那麼多亂七八糟的功能，只要能改鍵就好。keyd 是 Linux 上的一個簡單易用的替代品。缺點是沒有辦法按每個程序設置快捷鍵，只能設置全局快捷鍵。而且輸出受到鍵盤佈局影響，我同時使用 qwerty 的中文輸入和 dvorak，有時候就會出錯。\n","date":"2023-12-21T22:44:00+08:00","permalink":"https://evthron.github.io/zh/toolbox/remap-keyboard/","title":"重設鍵盤佈局"},{"content":"這可是拿過獎的！\nPrompt: a highly detailed oil painting of a cat walking in foggy london street, steampunk, gears, steam engine, by leonardo da Vinci, trending in artstation\nNegative prompt: monochrome, blurry, jpeg artifacts, worst quality, watermark\nSteps: 30\nSampler: DPM++ 2M Karras\nCFG scale: 10\nSeed: 189248350\nSize: 768x512\nModel hash: cc6cb27103\nModel: v1-5-pruned-emaonly\n","date":"2023-12-02T10:32:58+08:00","image":"https://evthron.github.io/zh/gallery/agi/london-cat_hu540022299591787024.png","permalink":"https://evthron.github.io/zh/gallery/agi/","title":"AI Generated Oil Painting"},{"content":"2022/12/29 09:36\n要是按照時區算的話，現在我正準備橫渡太平洋。\n事情要從考完試一覺睡到下午五點說起。按常理來說，想回到正常的作息，應該要再熬一天夜，或者用鬧鐘早起。換作平常，也沒別的辦法，這是考試熬夜不睡必然的後果。不過考完試還得熬夜，放假還得調鬧鐘不成？我就試了試別的辦法——把起床時間自然地調回去，幫自己倒時差。\n自己的時間是完全主觀的，不必和外面的世界同步。就算是大白天，人也未必睡不着覺。時差不就是這樣嗎？旅行坐飛機，出發是白天，坐了半天，下飛機還是白天。想要生理作息完全配合實際時間，不依靠鬧鐘是很難做到的。既然這樣，就把現在的狀況當做時差，利用生理時鐘和實際時間的差距，把時間調回去不就可以了嗎？\n透過大量精密且科學的統計數據可知，我的自然清醒時間是十六個小時左右，睡眠時間約是九個小時，也就是說，想過二十五、二十六小時的一天並不是難事。只要每天都把睡覺時間往後撥一個小時，兩個星期就能把起床時間改回早上八點。要改的不只是睡覺時間，用來分開早午晚的吃飯時間也要調整。結果我和太陽起落完全不同步，晚上十點起床，早上八點吃晚飯。深夜出不了門也不知道做甚麼好。\n現在的體感時間是GMT-6，還要一直往西邊減下去。真的是逆天而行啊，也只有放假的時候能讓我這樣折騰了。\n大概不能在新年前回到東八區。太平洋的水好涼。我到底要在哪個時區，過哪裏的新年呢？\n","date":"2023-12-02T08:13:39+08:00","permalink":"https://evthron.github.io/zh/posts/timezone/","title":"時區"},{"content":"2022/12/24 22:24\n爬山真是個讓人逃避現實的好興趣，因為這是個相當單純的活動，只需要一直往前走就可以了，無暇思考多餘的事。就算要跨過石頭，要踩過泥濘地，要跨過樹根，也只需要盯着腳下向前。不用管鞋子是不是進了水，不用管褲管是不是沾上了泥，只要能走就可以了。不用想走了多遠，不用知道還有多遠，甚至不用知道要去哪裏，只要一直往前走就可以了。是的，甚麼都不用想，千字的文章一筆未動也好，整個學期一竅不通也好，人既然遠離了無線電波，就跟外面的世界斷了聯繫。在人跡罕至的山裏，剩下的就只有人和自然的搏鬥。\n的確是搏鬥，這並不是因為爬山有多麼消耗體力，而是因為充滿障礙的環境消磨着人的理智。雨粉打在眼鏡上，忍受着白茫茫的視野前行，擦拭也沒有意義。在葉子叢中穿行時，枝葉不斷拍過臉、掃過臉，撥都撥不開；每個轉角必定有個斜坡，感受隨時會失足的刺激，濕潤的泥土上落腳；最後只能時不時喘氣、時不時抱怨、時不時怪叫。把不想淋雨的幻想和傘一起收回包裏，沒有餘裕擋雨；彎下腰避開枝葉，恨不得能在地上爬；抓緊粗糙的樹枝，為了不摔倒就得讓手指流血，然後繼續走下去。\n雖然撞上了壞天氣，但最後還是看到了點特別的景色。雨天裏迷霧遍佈的黃昏，看起來就像恐怖片裏陰森的清晨；水和天空交匯成一線白光，就像是世界的盡頭。\n","date":"2023-12-02T08:12:27+08:00","permalink":"https://evthron.github.io/zh/posts/mountain/","title":"登山"},{"content":" 素描就是死死盯着要畫的事物，再怎麽複雜也要想辦法把影像搬到紙上。\n","date":"2023-12-02T07:28:35+08:00","image":"https://evthron.github.io/zh/gallery/complex-scenary/nightview_hu5247823997815395626.jpg","permalink":"https://evthron.github.io/zh/gallery/complex-scenary/","title":"什麽都畫得出來"},{"content":"中學的時候參加中文學會的文社，老師給我們送了一本日記。然後我就從中二到中五寫了三年的日記。\n這本日記有366頁，每頁都印好了日期和三欄寫作空間，所以可以寫三年。寫作方法是這樣的：例如我在11月26日開始的話，會寫在11/26那一頁的第一欄，第二和第三欄留空。接下來的日子全部都寫在第一欄，直到一年過去，每一頁的第一欄都寫滿了，就下移到第二欄繼續，第二年到第三年也一樣。\n把三篇日記堆在同一頁的用意是，讓日記不再是寫了就忘的東西，而是會不時重新閱讀的文字記錄。寫着寫着，就會懂得把事情寫清楚。隱喻、省略、暗示都是沒有意思的，只會讓自己都讀不懂自己寫了甚麼。還有會避免寫出重複的東西，像是瑣事、抱怨，因為這樣讀起來一點都不有趣。\n這本日記除了編排很特別以外，每頁還附帶了問題，所以就算一天無事發生，也不愁沒東西可寫。我挑了三條有趣的出來：「你拖延了甚麼事情？」「在網上搜了甚麼？」「別人跟自己說的印象最深的話是？」\n我想每天都會寫東西的人不多，但只要有一本標好日期的實體本子，這習慣並不難培養，因為格子丟空了就是空了，補不回來很難受。我偶爾忘記寫，或者日記本沒帶在身上的時候，都要盡快補上去。哪怕只是過了一天，很多事情已經想不起來了。寫得好不好都沒有關係，畢竟日記又不用給別人看，哪會像這篇文章一樣難產。\n那麼我現在還有繼續寫日記嗎？沒有，我填滿日記本之後就乾脆利落地結束了。不過我現在很習慣隨手記下想法，還有用紙和筆考慮問題。文字是個很方便的工具，只要把腦海裏模糊又轉瞬即逝的想法統統落在紙上，就會變成具體實在、不會消失的句子。要理清思緒，沒有比這更好的方法了。不過說不定這是件可怕的事，因為如實思考自己在想甚麼，把這些想法原原本本地揭露出來，是很令人卻步的。所以每天都試着寫點甚麼吧，會越來越拿手的。\n","date":"2023-11-26T08:58:15+08:00","permalink":"https://evthron.github.io/zh/posts/diary/","title":"寫日記"},{"content":"取景框很有用，最好和畫紙一樣大。 ","date":"2023-07-23T04:39:53+08:00","image":"https://evthron.github.io/zh/gallery/park/bench_hu7084551511688450216.jpg","permalink":"https://evthron.github.io/zh/gallery/park/","title":"公園的座椅"},{"content":"看到什麽就畫什麽，真的就只是這樣。 ","date":"2023-05-22T18:46:01+08:00","image":"https://evthron.github.io/zh/gallery/shelf-site-sky/shelf-site-sky_hu5862360906872638610.jpg","permalink":"https://evthron.github.io/zh/gallery/shelf-site-sky/","title":"架子工地和雲"},{"content":"總算放假，得開始寫東西了。複習周一直被其他作業綁著，最後只剩下一天複習兩門課的考試。於是毅然決然在學校住了兩天，與其說是不受常識束縛的超人之舉。不如說是被逼到走投無路的下下策。\n最大的感受是自己的時間原來這么好用。從腦袋空空開始，慢慢從頭學回去。以三十分鐘為單位，循環十二次，六小時后又六小時，一直到學完后，還能因為考試時間沒到而不知所措，簡直取之不盡。其實沒有必要擔心時間不夠。平常的寶貴時間，就是在地鐵站到家之間、床到書桌之間、書桌到飯桌之間溜走的嗎？把這些平常人的生活全部拋棄掉！就能突破自我的極限——真的只能當作非常手段啊。\n晚上在沙發上坐著打盹是很痛苦的，醒來的時才算幸福。去了最早七點半開門的飯堂吃早餐，還要補充咖啡因。飯堂的純咖啡真的只是黑色的苦水，而且又酸又澀。雖然我對提神飲料的味道沒有追求。但還是很難下咽。\n咖啡的威力真的很強大，它不是能馬上起效的，而是不知不覺兩三個小時間，從昏昏沉沉過渡到睡意全無，令人驚訝自己過了這么久還不困。只要喝了這種東西，就好像能夠永遠清醒著工作，讓人忽略清醒和疲倦的界限，而且除了讓睡眠周期混亂以外，貌似也沒有其他副作用，真的是非常可怕。我只會把它當作秘密武器，不到最後不會隨便使用。\n現在考試結束后回家恍如隔世。這種一心一意的能量，要是不放在複習，而是放在其他事情上就好了，所以假期要好好充實地過。\n","date":"2023-05-16T20:41:00+08:00","permalink":"https://evthron.github.io/zh/posts/overnight-revision/","title":"通宵"},{"content":"Progress bar Component count: 12/100 --- Lv5 Clock Number field Vocab Tag all pos-adj pos-v pos-n fellow out of luck sleek livelihood gem phoenix attorney peril foresee keep you posted pay off Thumbnail progress bar file_count 309/336 Lv7 sitelen pona sijelo mi li ilo utala telo loje insa mi li kiwen. pilin mi li kule ala mi tawa e ma utala mute taso mi anpa ala mi anpa ala e jan ike mi sewi ala e jan ike poka mi li lon ala jan. mi ante e kiwen lon nena pi ilo utala ni la mi wile ala nasin pona sijelo mi li ilo utala mute\n","date":"0001-01-01T00:00:00Z","permalink":"https://evthron.github.io/zh/sandbox/arsenal/","title":"網頁組件"}]